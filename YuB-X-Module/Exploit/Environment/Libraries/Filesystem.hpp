#pragma once

#include <Windows.h>
#include <ShlObj.h>
#include <lstate.h>
#include <lualib.h>
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>
#include <sstream>

#include <Exploit/Utils.hpp>

namespace Filesystem
{
    std::filesystem::path get_workspace_path()
    {
        char app_data_path[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, app_data_path)))
        {
            std::filesystem::path workspace = std::filesystem::path(app_data_path) / "YuB-X-Public" / "workspace";
            if (!std::filesystem::exists(workspace))
            {
                std::filesystem::create_directories(workspace);
            }
            return workspace;
        }
        return std::filesystem::temp_directory_path() / "YuB-X-Public" / "workspace";
    }

    std::filesystem::path sanitize_path(const std::string& path)
    {
        std::filesystem::path workspace = get_workspace_path();
        std::filesystem::path full_path = workspace / path;
        
        std::error_code ec;
        std::filesystem::path canonical_path = std::filesystem::weakly_canonical(full_path, ec);
        
        if (ec)
        {
            return {};
        }

        std::string canonical_str = canonical_path.string();
        std::string workspace_str = workspace.string();
        
        if (canonical_str.length() < workspace_str.length() ||
            canonical_str.substr(0, workspace_str.length()) != workspace_str)
        {
            return {};
        }
        
        return canonical_path;
    }

    int writefile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        size_t data_len = 0;
        const char* data = luaL_checklstring(L, 2, &data_len);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }
        
        std::ofstream file(safe_path, std::ios::binary);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for writing");
            return 0;
        }
        
        file.write(data, data_len);
        file.close();
        
        return 0;
    }

    int readfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }
        
        if (!std::filesystem::exists(safe_path))
        {
            luaL_error(L, "File does not exist");
            return 0;
        }
        
        std::ifstream file(safe_path, std::ios::binary);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for reading");
            return 0;
        }
        
        std::stringstream buffer;
        buffer << file.rdbuf();
        file.close();
        
        std::string content = buffer.str();
        lua_pushlstring(L, content.data(), content.size());
        
        return 1;
    }

    int appendfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        size_t data_len = 0;
        const char* data = luaL_checklstring(L, 2, &data_len);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }
        
        std::ofstream file(safe_path, std::ios::binary | std::ios::app);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for appending");
            return 0;
        }
        
        file.write(data, data_len);
        file.close();
        
        return 0;
    }

    int isfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            lua_pushboolean(L, false);
            return 1;
        }
        
        bool exists = std::filesystem::exists(safe_path);
        bool is_file = std::filesystem::is_regular_file(safe_path);
        
        lua_pushboolean(L, exists && is_file);
        return 1;
    }

    int isfolder(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            lua_pushboolean(L, false);
            return 1;
        }
        
        bool exists = std::filesystem::exists(safe_path);
        bool is_dir = std::filesystem::is_directory(safe_path);
        
        lua_pushboolean(L, exists && is_dir);
        return 1;
    }

    int delfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }
        
        if (std::filesystem::exists(safe_path) && std::filesystem::is_regular_file(safe_path))
        {
            std::filesystem::remove(safe_path);
        }
        
        return 0;
    }

    int delfolder(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe folder path");
            return 0;
        }
        
        if (std::filesystem::exists(safe_path) && std::filesystem::is_directory(safe_path))
        {
            std::filesystem::remove_all(safe_path);
        }
        
        return 0;
    }

    int makefolder(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe folder path");
            return 0;
        }
        
        std::filesystem::create_directories(safe_path);
        
        return 0;
    }

    int listfiles(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe folder path");
            return 0;
        }
        
        if (!std::filesystem::exists(safe_path) || !std::filesystem::is_directory(safe_path))
        {
            lua_newtable(L);
            return 1;
        }
        
        lua_newtable(L);
        int index = 1;
        
        for (const auto& entry : std::filesystem::directory_iterator(safe_path))
        {
            lua_pushinteger(L, index);
            lua_pushstring(L, entry.path().filename().string().c_str());
            lua_settable(L, -3);
            index++;
        }
        
        return 1;
    }

    int loadfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }
        
        if (!std::filesystem::exists(safe_path))
        {
            luaL_error(L, "File does not exist");
            return 0;
        }
        
        std::ifstream file(safe_path, std::ios::binary);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for reading");
            return 0;
        }
        
        std::stringstream buffer;
        buffer << file.rdbuf();
        file.close();
        
        std::string content = buffer.str();
        std::string chunkname = "@" + safe_path.filename().string();
        
        int result = luaL_loadbuffer(L, content.data(), content.size(), chunkname.c_str());
        
        if (result != 0)
        {
            return 1;
        }
        
        return 1;
    }

    int getcustomasset(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        
        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }
        
        if (!std::filesystem::exists(safe_path))
        {
            luaL_error(L, "File does not exist");
            return 0;
        }
        
        std::string file_path = safe_path.string();
        std::string content_url = "file:///" + file_path;
        
        lua_pushstring(L, content_url.c_str());
        return 1;
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "writefile", Filesystem::writefile);
        Utils::AddFunction(L, "readfile", Filesystem::readfile);
        Utils::AddFunction(L, "appendfile", Filesystem::appendfile);
        Utils::AddFunction(L, "isfile", Filesystem::isfile);
        Utils::AddFunction(L, "isfolder", Filesystem::isfolder);
        Utils::AddFunction(L, "delfile", Filesystem::delfile);
        Utils::AddFunction(L, "delfolder", Filesystem::delfolder);
        Utils::AddFunction(L, "makefolder", Filesystem::makefolder);
        Utils::AddFunction(L, "listfiles", Filesystem::listfiles);
        Utils::AddFunction(L, "loadfile", Filesystem::loadfile);
        Utils::AddFunction(L, "getcustomasset", Filesystem::getcustomasset);
    }
}
