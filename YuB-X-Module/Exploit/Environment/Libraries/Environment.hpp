#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <string>
#include <vector>
#include <functional>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>

namespace EnvFunctions
{
    struct GCEnumContext
    {
        lua_State* L;
        bool includeTables;
        std::vector<GCObject*>* results;
    };

    static void GCEnumCallback(void* context, void* ptr, uint8_t tt, uint8_t memcat, size_t size, const char* name)
    {
        GCEnumContext* ctx = static_cast<GCEnumContext*>(context);
        
        // Skip dead objects
        if (isdead(ctx->L->global, static_cast<GCObject*>(ptr)))
            return;

        // Skip tables if not requested
        if (!ctx->includeTables && tt == LUA_TTABLE)
            return;

        // Only include functions, tables, and userdata
        if (tt == LUA_TFUNCTION || tt == LUA_TTABLE || tt == LUA_TUSERDATA)
        {
            ctx->results->push_back(static_cast<GCObject*>(ptr));
        }
    }

    static void GCEnumEdgeCallback(void* context, void* from, void* to, const char* name)
    {
        // Not needed for getgc
    }

    static void PushGCObject(lua_State* L, GCObject* obj)
    {
        if (!obj) return;

        TValue tv;
        tv.tt = obj->gch.tt;
        tv.value.gc = obj;

        setobj2s(L, L->top, &tv);
        L->top++;
    }

    int getgc(lua_State* L)
    {
        bool includeTables = lua_toboolean(L, 1) != 0;

        GCEnumContext ctx;
        ctx.L = L;
        ctx.includeTables = includeTables;
        std::vector<GCObject*> results;

        ctx.results = &results;
        luaC_enumheap(L, &ctx, GCEnumCallback, GCEnumEdgeCallback);

        lua_newtable(L);
        for (size_t i = 0; i < results.size(); i++)
        {
            PushGCObject(L, results[i]);
            lua_rawseti(L, -2, static_cast<int>(i + 1));
        }

        return 1;
    }

    int getreg(lua_State* L)
    {
        // The registry is stored at &L->global->registry
        // We need to get it as a table
        TValue* reg = registry(L);
        
        if (!reg || ttisnil(reg))
        {
            lua_newtable(L);
            return 1;
        }

        // Push the registry value onto the stack
        setobj2s(L, L->top, reg);
        L->top++;

        return 1;
    }

    int getrenv(lua_State* L)
    {
        // Get Roblox's global environment from the main thread
        lua_State* mainThread = L->global->mainthread;
        
        if (!mainThread)
        {
            // Fallback to current thread's globals
            lua_pushvalue(L, LUA_GLOBALSINDEX);
            return 1;
        }

        // Get the global table from the main thread
        lua_pushvalue(mainThread, LUA_GLOBALSINDEX);
        
        // Move to the current state
        lua_xmove(mainThread, L, 1);
        
        return 1;
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "getgc", EnvFunctions::getgc);
        Utils::AddFunction(L, "getreg", EnvFunctions::getreg);
        Utils::AddFunction(L, "getrenv", EnvFunctions::getrenv);
    }
}
