#include <Exploit/Environment/Environment.hpp>
#include <Exploit/Environment/Libraries/Http.hpp>
#include <Exploit/Environment/Libraries/Closures.hpp>
#include <Exploit/Environment/Libraries/Miscellaneous.hpp>
#include <Exploit/Environment/Libraries/Filesystem.hpp>
#include <Exploit/Environment/Libraries/Encoding.hpp>
#include <Exploit/Environment/Libraries/Instances.hpp>
#include <Exploit/Environment/Libraries/Environment.hpp>
#include <unordered_set>
#include <string>

lua_CFunction original_index;
lua_CFunction original_namecall;

static const std::unordered_set<std::string> unsafe_functions = {
    "TestService.Run", "TestService", "Run",
    "OpenVideosFolder", "OpenScreenshotsFolder", "GetRobuxBalance", "PerformPurchase",
    "PromptBundlePurchase", "PromptNativePurchase", "PromptProductPurchase", "PromptPurchase",
    "PromptThirdPartyPurchase", "Publish", "GetMessageId", "OpenBrowserWindow", "RequestInternal",
    "ExecuteJavaScript", "ToggleRecording", "TakeScreenshot", "HttpRequestAsync", "GetLast",
    "SendCommand", "GetAsync", "GetAsyncFullUrl", "RequestAsync", "MakeRequest",
    "AddCoreScriptLocal", "SaveScriptProfilingData", "GetUserSubscriptionDetailsInternalAsync",
    "GetUserSubscriptionStatusAsync", "PerformBulkPurchase", "PerformCancelSubscription",
    "PerformPurchaseV2", "PerformSubscriptionPurchase", "PerformSubscriptionPurchaseV2",
    "PrepareCollectiblesPurchase", "PromptBulkPurchase", "PromptCancelSubscription",
    "PromptCollectiblesPurchase", "PromptGamePassPurchase", "PromptNativePurchaseWithLocalPlayer",
    "PromptPremiumPurchase", "PromptRobloxPurchase", "PromptSubscriptionPurchase",
    "ReportAbuse", "ReportAbuseV3", "ReturnToJavaScript", "OpenNativeOverlay",
    "OpenWeChatAuthWindow", "EmitHybridEvent", "OpenUrl", "PostAsync", "PostAsyncFullUrl",
    "RequestLimitedAsync", "Load", "CaptureScreenshot", "CreatePostAsync", "DeleteCapture",
    "DeleteCapturesAsync", "GetCaptureFilePathAsync", "SaveCaptureToExternalStorage",
    "SaveCapturesToExternalStorageAsync", "GetCaptureUploadDataAsync", "RetrieveCaptures",
    "SaveScreenshotCapture", "Call", "GetProtocolMethodRequestMessageId",
    "GetProtocolMethodResponseMessageId", "PublishProtocolMethodRequest",
    "PublishProtocolMethodResponse", "Subscribe", "SubscribeToProtocolMethodRequest",
    "SubscribeToProtocolMethodResponse", "GetDeviceIntegrityToken", "GetDeviceIntegrityTokenYield",
    "NoPromptCreateOutfit", "NoPromptDeleteOutfit", "NoPromptRenameOutfit", "NoPromptSaveAvatar",
    "NoPromptSaveAvatarThumbnailCustomization", "NoPromptSetFavorite", "NoPromptUpdateOutfit",
    "PerformCreateOutfitWithDescription", "PerformRenameOutfit", "PerformSaveAvatarWithDescription",
    "PerformSetFavorite", "PerformUpdateOutfit", "PromptCreateOutfit", "PromptDeleteOutfit",
    "PromptRenameOutfit", "PromptSaveAvatar", "PromptSetFavorite", "PromptUpdateOutfit"
};

int index_hook(lua_State* L)
{
    if (L->userdata->capabilities == max_capabilities)
    {
        std::string key = lua_isstring(L, 2) ? lua_tostring(L, 2) : "";
        if (unsafe_functions.count(key))
        {
            roblox::print(3, "function '%s' has been disabled for security reasons", key.c_str());
            return 0;
        }

        if (L->userdata->script.expired())
        {
            if (key == "HttpGet" || key == "HttpGetAsync")
            {
                lua_pushcclosure(L, http::http_get, nullptr, 0);
                return 1;
            }
            else if (key == "GetObjects")
            {
                lua_pushcclosure(L, miscellaneous::get_objects, nullptr, 0);
                return 1;
            }
        }
    }

    return original_index(L);
};

int namecall_hook(lua_State* L)
{
    if (L->userdata->capabilities == max_capabilities)
    {
        std::string key = L->namecall->data;
        if (unsafe_functions.count(key))
        {
            roblox::print(3, "function '%s' has been disabled for security reasons", key.c_str());
            return 0;
        }

        if (L->userdata->script.expired())
        {
            if (key == "HttpGet" || key == "HttpGetAsync")
            {
                return http::http_get(L);
            }
            else if (key == "GetObjects")
            {
                return miscellaneous::get_objects(L);
            }
        }
    }

    return original_namecall(L);
};

void cfg_add_page(int64_t r8_2)
{
    int64_t r9_13 = r8_2 & 0xfffffffffffff000;
    int32_t* r11_30 = (int32_t*)((r9_13 >> 0xf) + ((uintptr_t)GetModuleHandleA("RobloxPlayerBeta.dll") + 0x1682ab0));
    *r11_30 |= 1 << (((r8_2 & 0xfffff000) >> 0xc & 7) % 0x20);
}

void initialize_hooks(lua_State* L)
{
    int original_top = lua_gettop(L);

    lua_getglobal(L, "game");
    luaL_getmetafield(L, -1, "__index");
    if (lua_type(L, -1) == LUA_TFUNCTION || lua_type(L, -1) == LUA_TLIGHTUSERDATA)
    {
        Closure* index_closure = clvalue(luaA_toobject(L, -1));
        original_index = index_closure->c.f;
        index_closure->c.f = index_hook;
    }
    lua_pop(L, 1);

    luaL_getmetafield(L, -1, "__namecall");
    if (lua_type(L, -1) == LUA_TFUNCTION || lua_type(L, -1) == LUA_TLIGHTUSERDATA)
    {
        Closure* namecall_closure = clvalue(luaA_toobject(L, -1));
        original_namecall = namecall_closure->c.f;
        namecall_closure->c.f = namecall_hook;
    }
    lua_pop(L, 1);

    lua_settop(L, original_top);
}

void environment::setup_environment(lua_State* L)
{
    luaL_sandboxthread(L);

    closures::register_lib(L);
    http::register_lib(L);
    miscellaneous::register_lib(L);
    filesystem::register_lib(L);
    encoding::register_lib(L);
    instances::register_lib(L);
    env_functions::register_lib(L);

    initialize_hooks(L);
    luaL_sandboxthread(L);

    lua_newtable(L);
    lua_setglobal(L, "_G");

    lua_newtable(L);
    lua_setglobal(L, "shared");
}
