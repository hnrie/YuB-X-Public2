#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <unordered_map>
#include <memory>
#include <functional>
#include <cstring>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>
#include <Exploit/Execution/Execution.hpp>
#include <Exploit/TaskScheduler/TaskScheduler.hpp>

namespace closures
{
    struct hooked_function
    {
        lua_CFunction original;
        bool is_metamethod;
        void* target;
        
        hooked_function(lua_CFunction orig, bool meta = false, void* tgt = nullptr) 
            : original(orig), is_metamethod(meta), target(tgt) {}
    };

    inline std::unordered_map<void*, hooked_function> hooked_functions;
    inline std::unordered_map<void*, lua_CFunction> wrapped_closures;
    inline std::mutex hook_mutex;

    int load_string(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TSTRING);

        const char* chunk_name = luaL_optstring(L, 2, "");
        std::string bytecode = execution::compile_script(lua_tostring(L, 1));
        if (luau_load(L, chunk_name, bytecode.data(), bytecode.size(), 0) != LUA_OK)
        {
            lua_pushnil(L);
            lua_pushvalue(L, -2);
            return 2;
        }

        Closure* closure = clvalue(luaA_toobject(L, -1));
        task_scheduler::set_proto_capabilities(closure->l.p, &max_capabilities);
        lua_setsafeenv(L, LUA_GLOBALSINDEX, false);

        return 1;
    }

    int check_caller(lua_State* L)
    {
        lua_pushboolean(L, L == shared_variables::exploit_thread);
        return 1;
    }

    int is_c_closure(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if (!lua_isfunction(L, 1))
        {
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        Closure* closure = clvalue(luaA_toobject(L, 1));
        lua_pushboolean(L, closure->isC);
        return 1;
    }

    int is_l_closure(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if (!lua_isfunction(L, 1))
        {
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        Closure* closure = clvalue(luaA_toobject(L, 1));
        lua_pushboolean(L, !closure->isC);
        return 1;
    }

    int is_executor_closure(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if (!lua_isfunction(L, 1))
        {
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        Closure* closure = clvalue(luaA_toobject(L, 1));
        
        if (!closure->isC)
        {
            lua_pushboolean(L, false);
            return 1;
        }

        lua_pushboolean(L, closure->c.f != nullptr);
        return 1;
    }

    int clone_function(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* original = clvalue(luaA_toobject(L, 1));
        
        if (original->isC)
        {
            lua_pushcclosure(L, original->c.f, nullptr, 0);
        }
        else
        {
            if (!original->l.p)
            {
                luaL_error(L, "cannot clone function without proto");
                return 0;
            }

            lua_newuserdatadtor(L, sizeof(Closure), [](lua_State*, void* p) {});
            
            Closure* new_closure = clvalue(luaA_toobject(L, -1));
            memset(new_closure, 0, sizeof(Closure));
            new_closure->gch.tt = LUA_TFUNCTION;
            new_closure->gch.marked = 0;
            new_closure->isC = 0;
            new_closure->nupvalues = original->nupvalues;
            new_closure->stacksize = original->stacksize;
            new_closure->env = original->env;
            new_closure->l.p = original->l.p;
            
            lua_createtable(L, original->nupvalues, 0);
            for (int i = 0; i < original->nupvalues; i++)
            {
                lua_pushvalue(L, 1);
                lua_getupvalue(L, -1, i + 1);
                lua_setupvalue(L, -2, i + 1);
                lua_pop(L, 1);
            }
            
            lua_pop(L, 1);
        }

        return 1;
    }

    int new_c_closure(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* func_closure = clvalue(luaA_toobject(L, 1));
        
        if (!func_closure->isC)
        {
            luaL_error(L, "expected c function, got lua function");
            return 0;
        }
        
        lua_CFunction wrapped_function = func_closure->c.f;
        
        static int closure_id = 0;
        int id = ++closure_id;
        
        std::lock_guard<std::mutex> lock(hook_mutex);
        wrapped_closures[reinterpret_cast<void*>(id)] = wrapped_function;

        lua_CFunction c_closure_wrapper = [](lua_State* L) -> int
        {
            Closure* caller = curr_func(L);
            if (!caller || !caller->isC)
            {
                return luaL_error(L, "newcclosure can only be called from c");
            }
            
            void* upvalue = lua_getupvalue(L, 1, 1);
            if (!upvalue)
            {
                return luaL_error(L, "invalid closure upvalue");
            }
            
            if (!lua_islightuserdata(L, -1))
            {
                lua_pop(L, 1);
                return luaL_error(L, "invalid closure upvalue type");
            }
            
            void* id_ptr = lua_touserdata(L, -1);
            lua_pop(L, 1);
            
            if (!id_ptr)
            {
                return luaL_error(L, "invalid closure id");
            }
            
            int id = static_cast<int>(reinterpret_cast<uintptr_t>(id_ptr));
            
            std::lock_guard<std::mutex> lock(hook_mutex);
            auto it = wrapped_closures.find(reinterpret_cast<void*>(id));
            if (it == wrapped_closures.end())
            {
                return luaL_error(L, "closure not found");
            }
            
            return it->second(L);
        };

        lua_pushlightuserdata(L, reinterpret_cast<void*>(id));
        lua_pushcclosure(L, c_closure_wrapper, 1);

        return 1;
    }

    int hook_function(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function for argument 1, got %s", lua_typename(L, lua_type(L, 1)));
        
        if (!lua_isfunction(L, 2))
            luaL_error(L, "expected function for argument 2, got %s", lua_typename(L, lua_type(L, 2)));

        Closure* original_closure = clvalue(luaA_toobject(L, 1));
        Closure* hook_closure = clvalue(luaA_toobject(L, 2));

        std::lock_guard<std::mutex> lock(hook_mutex);
        
        if (original_closure->isC)
        {
            hooked_functions[reinterpret_cast<void*>(original_closure->c.f)] = 
                hooked_function(original_closure->c.f);
            original_closure->c.f = hook_closure->c.f;
        }
        else
        {
            luaL_error(L, "cannot hook lua functions directly");
            return 0;
        }

        lua_pushvalue(L, 1);
        return 1;
    }

    int restore_function(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* closure = clvalue(luaA_toobject(L, 1));

        std::lock_guard<std::mutex> lock(hook_mutex);
        
        if (closure->isC)
        {
            auto it = hooked_functions.find(reinterpret_cast<void*>(closure->c.f));
            if (it != hooked_functions.end())
            {
                closure->c.f = it->second.original;
                hooked_functions.erase(it);
                lua_pushboolean(L, true);
            }
            else
            {
                lua_pushboolean(L, false);
            }
        }
        else
        {
            lua_pushboolean(L, false);
        }

        return 1;
    }

    int hook_metamethod(lua_State* L)
    {
        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
            luaL_error(L, "expected table or userdata for argument 1, got %s", lua_typename(L, lua_type(L, 1)));
        
        if (!lua_isstring(L, 2))
            luaL_error(L, "expected string for argument 2, got %s", lua_typename(L, lua_type(L, 1)));
        
        if (!lua_isfunction(L, 3))
            luaL_error(L, "expected function for argument 3, got %s", lua_typename(L, lua_type(L, 2)));

        const char* metamethod_name = lua_tostring(L, 2);
        
        if (!lua_getmetatable(L, 1))
        {
            lua_createtable(L, 0, 1);
            lua_setmetatable(L, 1);
            lua_getmetatable(L, 1);
        }

        lua_CFunction original = nullptr;
        if (lua_getfield(L, -1, metamethod_name) == LUA_TFUNCTION)
        {
            original = lua_tocfunction(L, -1);
            lua_pop(L, 1);
        }
        else
        {
            lua_pop(L, 1);
        }

        Closure* hook_closure = clvalue(luaA_toobject(L, 3));
        
        std::lock_guard<std::mutex> lock(hook_mutex);
        
        if (original)
        {
            hooked_functions[reinterpret_cast<void*>(hook_closure->c.f)] = 
                hooked_function(original, true, nullptr);
        }

        lua_pushcclosure(L, hook_closure->c.f, 0);
        lua_setfield(L, -2, metamethod_name);

        lua_pop(L, 1);
        
        lua_pushvalue(L, 1);
        lua_pushstring(L, metamethod_name);
        
        return 2;
    }

    int get_function_hash(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* closure = clvalue(luaA_toobject(L, 1));
        
        uintptr_t hash_value = 0;
        if (closure->isC)
        {
            hash_value = reinterpret_cast<uintptr_t>(closure->c.f);
        }
        else
        {
            hash_value = reinterpret_cast<uintptr_t>(closure->l.p);
        }

        hash_value = (hash_value >> 4) ^ (hash_value << 5);
        hash_value = (hash_value >> 4) ^ (hash_value << 5);
        hash_value = (hash_value >> 4) ^ (hash_value << 5);
        hash_value = (hash_value >> 4) ^ (hash_value << 5);

        lua_pushinteger(L, static_cast<lua_Integer>(hash_value));
        return 1;
    }

    void register_lib(lua_State* L)
    {
        utils::add_function(L, "loadstring", closures::load_string);
        utils::add_function(L, "checkcaller", closures::check_caller);
        utils::add_function(L, "iscclosure", closures::is_c_closure);
        utils::add_function(L, "islclosure", closures::is_l_closure);
        utils::add_function(L, "isexecutorclosure", closures::is_executor_closure);
        utils::add_function(L, "clonefunction", closures::clone_function);
        utils::add_function(L, "newcclosure", closures::new_c_closure);
        utils::add_function(L, "hookfunction", closures::hook_function);
        utils::add_function(L, "restorefunction", closures::restore_function);
        utils::add_function(L, "hookmetamethod", closures::hook_metamethod);
        utils::add_function(L, "getfunctionhash", closures::get_function_hash);
    }
}
