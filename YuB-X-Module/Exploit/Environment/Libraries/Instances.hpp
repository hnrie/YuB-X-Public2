#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lualib.h>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>

namespace instances
{
    int get_instances(lua_State* L)
    {
        lua_getglobal(L, "game");
        if (!lua_istable(L, -1) && !lua_isuserdata(L, -1))
        {
            lua_pop(L, 1);
            lua_newtable(L);
            return 1;
        }

        lua_getfield(L, -1, "GetDescendants");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 2);
            lua_newtable(L);
            return 1;
        }

        lua_pushvalue(L, -2);
        int status = lua_pcall(L, 1, 1, 0);

        if (status != LUA_OK || !lua_istable(L, -1))
        {
            if (status != LUA_OK)
                lua_pop(L, 1);
            lua_newtable(L);
        }

        lua_remove(L, -2);
        return 1;
    }

    int get_nil_instances(lua_State* L)
    {
        lua_newtable(L);
        int index = 1;

        lua_getglobal(L, "game");
        if (!lua_istable(L, -1) && !lua_isuserdata(L, -1))
        {
            lua_pop(L, 1);
            return 1;
        }

        lua_getfield(L, -1, "GetDescendants");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 2);
            return 1;
        }

        lua_pushvalue(L, -2);
        int status = lua_pcall(L, 1, 1, 0);

        if (status != LUA_OK || !lua_istable(L, -1))
        {
            lua_pop(L, status != LUA_OK ? 2 : 3);
            return 1;
        }

        lua_pushnil(L);
        while (lua_next(L, -2))
        {
            if (lua_istable(L, -1) || lua_isuserdata(L, -1))
            {
                lua_getfield(L, -1, "Parent");
                bool is_nil = lua_isnil(L, -1);
                lua_pop(L, 1);

                if (is_nil)
                {
                    lua_pushinteger(L, index);
                    lua_pushvalue(L, -2);
                    lua_settable(L, -5);
                    index++;
                }
            }
            lua_pop(L, 1);
        }

        lua_pop(L, 2);
        return 1;
    }

    int compare_instances(lua_State* L)
    {
        if (lua_isnoneornil(L, 1) || lua_isnoneornil(L, 2))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if ((!lua_istable(L, 1) && !lua_isuserdata(L, 1)) ||
            (!lua_istable(L, 2) && !lua_isuserdata(L, 2)))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        bool same = lua_rawequal(L, -1, -2);
        lua_pop(L, 2);

        if (!same)
        {
            if (lua_getmetatable(L, 1) && lua_getmetatable(L, 2))
            {
                same = lua_rawequal(L, -1, -2);
            }
            lua_pop(L, 2);
        }

        lua_pushboolean(L, same);
        return 1;
    }

    int clone_ref(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushnil(L);
            return 1;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        lua_newtable(L);

        lua_pushvalue(L, 1);
        lua_setfield(L, -2, "__ref");

        lua_newtable(L);
        lua_pushcclosure(L, [](lua_State* LS) -> int
        {
            lua_getfield(LS, 1, "__ref");
            if (lua_isnoneornil(LS, -1))
            {
                lua_pop(LS, 1);
                return 0;
            }

            const char* key = lua_tostring(LS, 2);
            if (!key)
            {
                lua_pop(LS, 1);
                return 0;
            }

            lua_getfield(LS, -1, key);
            lua_replace(LS, -2);
            return 1;
        }, nullptr, 0);
        lua_setfield(L, -2, "__index");

        lua_pushcclosure(L, [](lua_State* LS) -> int
        {
            lua_getfield(LS, 1, "__ref");
            if (lua_isnoneornil(LS, -1))
            {
                lua_pop(LS, 1);
                return 0;
            }

            lua_pushvalue(LS, 2);
            lua_pushvalue(LS, 3);
            lua_settable(LS, -3);
            lua_pop(LS, 1);
            return 0;
        }, nullptr, 0);
        lua_setfield(L, -2, "__newindex");

        lua_pushcclosure(L, [](lua_State* LS) -> int
        {
            lua_getfield(LS, 1, "__ref");
            if (lua_isnoneornil(LS, -1))
            {
                lua_pop(LS, 1);
                lua_pushboolean(LS, false);
                return 1;
            }

            lua_pushvalue(LS, 2);
            bool eq = lua_rawequal(LS, -1, -2);
            lua_pop(LS, 2);
            lua_pushboolean(LS, !eq);
            return 1;
        }, nullptr, 0);
        lua_setfield(L, -2, "__eq");

        lua_setmetatable(L, -2);
        return 1;
    }

    int get_hui(lua_State* L)
    {
        lua_getglobal(L, "game");
        if (!lua_istable(L, -1) && !lua_isuserdata(L, -1))
        {
            lua_pop(L, 1);
            lua_pushnil(L);
            return 1;
        }

        lua_getfield(L, -1, "GetService");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 2);
            lua_pushnil(L);
            return 1;
        }

        lua_pushvalue(L, -2);
        lua_pushstring(L, "CoreGui");
        int status = lua_pcall(L, 2, 1, 0);

        if (status != LUA_OK || lua_isnil(L, -1))
        {
            lua_pop(L, status != LUA_OK ? 2 : 1);
            lua_pushnil(L);
            return 1;
        }

        lua_remove(L, -2);
        return 1;
    }

    int fire_click_detector(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected clickdetector, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected clickdetector, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        lua_getfield(L, 1, "Parent");
        if (lua_isnoneornil(L, -1))
        {
            lua_pop(L, 1);
            luaL_error(L, "clickdetector has no parent");
            return 0;
        }
        lua_pop(L, 1);

        double distance = luaL_optnumber(L, 2, 9e9);
        const char* event = luaL_optstring(L, 3, "MouseClick");

        lua_getglobal(L, "game");
        lua_getfield(L, -1, "GetService");
        lua_pushvalue(L, -2);
        lua_pushstring(L, "Players");
        lua_pcall(L, 2, 1, 0);
        lua_remove(L, -2);

        lua_getfield(L, -1, "LocalPlayer");
        lua_remove(L, -2);

        if (lua_isnil(L, -1))
        {
            lua_pop(L, 1);
            luaL_error(L, "no localplayer found");
            return 0;
        }

        lua_getfield(L, 1, event);
        if (lua_isfunction(L, -1))
        {
            lua_pushvalue(L, 1);
            lua_pushvalue(L, -3);
            lua_pushnumber(L, distance);
            lua_pcall(L, 3, 0, 0);
        }
        else
        {
            lua_pop(L, 1);

            lua_getfield(L, 1, "Fire");
            if (lua_isfunction(L, -1))
            {
                lua_pushvalue(L, 1);
                lua_pushvalue(L, -3);
                lua_pushnumber(L, distance);
                lua_pcall(L, 3, 0, 0);
            }
            else
            {
                lua_pop(L, 1);
            }
        }

        lua_pop(L, 1);
        return 0;
    }

    int fire_touch_interest(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected basepart for argument 1, got nil");
            return 0;
        }

        if (lua_isnoneornil(L, 2))
        {
            luaL_error(L, "expected basepart for argument 2, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected basepart for argument 1, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        if (!lua_istable(L, 2) && !lua_isuserdata(L, 2))
        {
            luaL_error(L, "expected basepart for argument 2, got %s", lua_typename(L, lua_type(L, 2)));
            return 0;
        }

        int toggle = 0;
        if (lua_isboolean(L, 3))
        {
            toggle = lua_toboolean(L, 3) ? 0 : 1;
        }
        else if (lua_isnumber(L, 3))
        {
            toggle = static_cast<int>(lua_tonumber(L, 3));
        }

        const char* event_name = (toggle == 0) ? "Touch" : "TouchEnded";

        lua_getfield(L, 2, event_name);
        if (lua_isfunction(L, -1))
        {
            lua_pushvalue(L, 2);
            lua_pushvalue(L, 1);
            lua_pcall(L, 2, 0, 0);
        }
        else
        {
            lua_pop(L, 1);
        }

        return 0;
    }

    int fire_proximity_prompt(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected proximityprompt, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected proximityprompt, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        lua_getfield(L, 1, "Fire");
        if (lua_isfunction(L, -1))
        {
            lua_pushvalue(L, 1);
            lua_pcall(L, 1, 0, 0);
        }
        else
        {
            lua_pop(L, 1);

            lua_getfield(L, 1, "InputHoldBegin");
            if (lua_isfunction(L, -1))
            {
                lua_pushvalue(L, 1);
                lua_pcall(L, 1, 0, 0);
            }
            lua_pop(L, 1);

            lua_getfield(L, 1, "InputHoldEnd");
            if (lua_isfunction(L, -1))
            {
                lua_pushvalue(L, 1);
                lua_pcall(L, 1, 0, 0);
            }
            lua_pop(L, 1);

            lua_getfield(L, 1, "Triggered");
            if (lua_istable(L, -1) || lua_isuserdata(L, -1))
            {
                lua_getfield(L, -1, "Fire");
                if (lua_isfunction(L, -1))
                {
                    lua_pushvalue(L, -2);
                    lua_pcall(L, 1, 0, 0);
                }
                else
                {
                    lua_pop(L, 1);
                }
            }
            lua_pop(L, 1);
        }

        return 0;
    }

    int get_callback_value(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected instance, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        const char* property = luaL_checkstring(L, 2);
        if (!property)
        {
            lua_pushnil(L);
            return 1;
        }

        lua_getfield(L, 1, property);
        return 1;
    }

    void register_lib(lua_State* L)
    {
        utils::add_function(L, "getinstances", instances::get_instances);
        utils::add_function(L, "getnilinstances", instances::get_nil_instances);
        utils::add_function(L, "compareinstances", instances::compare_instances);
        utils::add_function(L, "cloneref", instances::clone_ref);
        utils::add_function(L, "gethui", instances::get_hui);
        utils::add_function(L, "fireclickdetector", instances::fire_click_detector);
        utils::add_function(L, "firetouchinterest", instances::fire_touch_interest);
        utils::add_function(L, "fireproximityprompt", instances::fire_proximity_prompt);
        utils::add_function(L, "getcallbackvalue", instances::get_callback_value);
    }
}
