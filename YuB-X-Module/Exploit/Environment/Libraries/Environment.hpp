#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <string>
#include <vector>
#include <functional>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>

namespace env_functions
{
    struct gc_enum_context
    {
        lua_State* L;
        bool include_tables;
        std::vector<GCObject*>* results;
    };

    static void gc_enum_callback(void* context, void* ptr, uint8_t tt, uint8_t memcat, size_t size, const char* name)
    {
        gc_enum_context* ctx = static_cast<gc_enum_context*>(context);
        
        if (isdead(ctx->L->global, static_cast<GCObject*>(ptr)))
            return;

        if (!ctx->include_tables && tt == LUA_TTABLE)
            return;

        if (tt == LUA_TFUNCTION || tt == LUA_TTABLE || tt == LUA_TUSERDATA)
        {
            ctx->results->push_back(static_cast<GCObject*>(ptr));
        }
    }

    static void gc_enum_edge_callback(void* context, void* from, void* to, const char* name)
    {
    }

    static void push_gc_object(lua_State* L, GCObject* obj)
    {
        if (!obj) return;

        TValue tv;
        tv.tt = obj->gch.tt;
        tv.value.gc = obj;
        
        setobj2s(L, L->top, &tv);
        api_incr_top(L);
    }

    int get_gc(lua_State* L)
    {
        bool include_tables = lua_toboolean(L, 1) != 0;

        gc_enum_context ctx;
        ctx.L = L;
        ctx.include_tables = include_tables;
        std::vector<GCObject*> results;

        ctx.results = &results;
        luaC_enumheap(L, &ctx, gc_enum_callback, gc_enum_edge_callback);

        lua_newtable(L);
        for (size_t i = 0; i < results.size(); i++)
        {
            push_gc_object(L, results[i]);
            lua_rawseti(L, -2, i + 1);
        }

        return 1;
    }

    int get_reg(lua_State* L)
    {
        TValue* reg = registry(L);
        
        if (!reg || ttisnil(reg))
        {
            lua_newtable(L);
            return 1;
        }

        setobj2s(L, L->top, reg);
        api_incr_top(L);

        return 1;
    }

    int get_renv(lua_State* L)
    {
        lua_State* main_thread = L->global->mainthread;
        
        if (!main_thread)
        {
            lua_pushvalue(L, LUA_GLOBALSINDEX);
            return 1;
        }

        lua_pushvalue(main_thread, LUA_GLOBALSINDEX);
        
        lua_xmove(main_thread, L, 1);
        
        return 1;
    }

    void register_lib(lua_State* L)
    {
        utils::add_function(L, "getgc", env_functions::get_gc);
        utils::add_function(L, "getreg", env_functions::get_reg);
        utils::add_function(L, "getrenv", env_functions::get_renv);
    }
}
