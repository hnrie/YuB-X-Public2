#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lualib.h>
#include <string>
#include <sstream>
#include <iomanip>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>
#include <Exploit/Execution/Execution.hpp>
#include <Exploit/TaskScheduler/TaskScheduler.hpp>

namespace Scripts
{
    static int AbsoluteIndex(lua_State* L, int index)
    {
        if (index > 0 || index <= LUA_REGISTRYINDEX)
            return index;
        return lua_gettop(L) + index + 1;
    }

    static int SafeGetFieldThunk(lua_State* L)
    {
        const char* fieldName = lua_tostring(L, lua_upvalueindex(2));
        lua_pushvalue(L, lua_upvalueindex(1));
        lua_getfield(L, -1, fieldName ? fieldName : "");
        return 1;
    }

    static bool SafeGetField(lua_State* L, int index, const char* fieldName)
    {
        index = AbsoluteIndex(L, index);

        lua_getglobal(L, "pcall");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 1);
            return false;
        }

        lua_pushvalue(L, index);
        lua_pushstring(L, fieldName);
        lua_pushcclosurek(L, SafeGetFieldThunk, nullptr, 2, nullptr);

        if (lua_pcall(L, 1, 2, 0) != LUA_OK)
        {
            lua_pop(L, 1);
            return false;
        }

        if (!lua_toboolean(L, -2))
        {
            lua_pop(L, 2);
            return false;
        }

        lua_remove(L, -2);
        return true;
    }

    static bool CallIsA(lua_State* L, int index, const char* className)
    {
        index = AbsoluteIndex(L, index);

        lua_getfield(L, index, "IsA");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 1);
            return false;
        }

        lua_pushvalue(L, index);
        lua_pushstring(L, className);

        if (lua_pcall(L, 2, 1, 0) != LUA_OK)
        {
            lua_pop(L, 1);
            return false;
        }

        bool isA = lua_toboolean(L, -1) != 0;
        lua_pop(L, 1);
        return isA;
    }

    static bool IsScriptInstance(lua_State* L, int index)
    {
        return CallIsA(L, index, "LuaSourceContainer") ||
            CallIsA(L, index, "LocalScript") ||
            CallIsA(L, index, "ModuleScript") ||
            CallIsA(L, index, "Script");
    }

    static bool GetScriptSource(lua_State* L, int index, std::string& outSource)
    {
        if (!SafeGetField(L, index, "Source"))
            return false;

        if (!lua_isstring(L, -1))
        {
            lua_pop(L, 1);
            return false;
        }

        size_t length = 0;
        const char* source = lua_tolstring(L, -1, &length);
        outSource.assign(source ? source : "", length);
        lua_pop(L, 1);
        return true;
    }

    static std::string HashBytecode(const std::string& data)
    {
        constexpr uint64_t kOffset = 14695981039346656037ull;
        constexpr uint64_t kPrime = 1099511628211ull;
        uint64_t hash = kOffset;

        for (unsigned char ch : data)
        {
            hash ^= ch;
            hash *= kPrime;
        }

        std::ostringstream stream;
        stream << std::hex << std::setw(16) << std::setfill('0') << hash;
        return stream.str();
    }

    static int RequireModuleClosure(lua_State* L)
    {
        lua_getglobal(L, "require");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 1);
            return 0;
        }

        lua_pushvalue(L, lua_upvalueindex(1));
        if (lua_pcall(L, 1, 1, 0) != LUA_OK)
        {
            lua_pop(L, 1);
            return 0;
        }

        return 1;
    }

    static int BuildScriptsTable(lua_State* L)
    {
        lua_getglobal(L, "game");
        if (!lua_istable(L, -1) && !lua_isuserdata(L, -1))
        {
            lua_pop(L, 1);
            lua_newtable(L);
            return 1;
        }

        lua_getfield(L, -1, "GetDescendants");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 2);
            lua_newtable(L);
            return 1;
        }

        lua_pushvalue(L, -2);
        if (lua_pcall(L, 1, 1, 0) != LUA_OK)
        {
            lua_pop(L, 2);
            lua_newtable(L);
            return 1;
        }

        if (!lua_istable(L, -1))
        {
            lua_pop(L, 2);
            lua_newtable(L);
            return 1;
        }

        lua_remove(L, -2);

        int descendantsIndex = AbsoluteIndex(L, -1);

        lua_newtable(L);
        int outputIndex = AbsoluteIndex(L, -1);
        int outputCounter = 1;

        lua_pushnil(L);
        while (lua_next(L, descendantsIndex) != 0)
        {
            if (IsScriptInstance(L, -1))
            {
                lua_pushvalue(L, -1);
                lua_rawseti(L, outputIndex, outputCounter++);
            }
            lua_pop(L, 1);
        }

        lua_remove(L, descendantsIndex);
        return 1;
    }

    int getscripts(lua_State* L)
    {
        return BuildScriptsTable(L);
    }

    int getrunningscripts(lua_State* L)
    {
        return BuildScriptsTable(L);
    }

    int getscriptenv(lua_State* L)
    {
        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected Instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        lua_State* mainThread = L->global->mainthread;
        if (!mainThread)
        {
            lua_pushvalue(L, LUA_GLOBALSINDEX);
            return 1;
        }

        lua_pushvalue(mainThread, LUA_GLOBALSINDEX);
        lua_xmove(mainThread, L, 1);
        return 1;
    }

    int getscriptbytecode(lua_State* L)
    {
        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected Instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        std::string source;
        if (!GetScriptSource(L, 1, source))
        {
            lua_pushnil(L);
            return 1;
        }

        std::string bytecode = Execution::CompileScript(source);
        lua_pushlstring(L, bytecode.data(), bytecode.size());
        return 1;
    }

    int getscripthash(lua_State* L)
    {
        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected Instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        std::string source;
        if (!GetScriptSource(L, 1, source))
        {
            lua_pushnil(L);
            return 1;
        }

        std::string bytecode = Execution::CompileScript(source);
        std::string hash = HashBytecode(bytecode);
        lua_pushstring(L, hash.c_str());
        return 1;
    }

    int getscriptclosure(lua_State* L)
    {
        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected Instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        std::string source;
        if (GetScriptSource(L, 1, source))
        {
            std::string bytecode = Execution::CompileScript(source);
            std::string chunkname = "@script";
            bool hasName = SafeGetField(L, 1, "Name");
            if (hasName && lua_isstring(L, -1))
            {
                chunkname = "@" + std::string(lua_tostring(L, -1));
            }
            if (hasName)
            {
                lua_pop(L, 1);
            }

            if (luau_load(L, chunkname.c_str(), bytecode.data(), bytecode.size(), 0) != LUA_OK)
            {
                lua_pop(L, 1);
                lua_pushnil(L);
                return 1;
            }

            Closure* closure = clvalue(luaA_toobject(L, -1));
            TaskScheduler::SetProtoCapabilities(closure->l.p, &MaxCapabilities);
            lua_setsafeenv(L, LUA_GLOBALSINDEX, false);
            return 1;
        }

        if (IsScriptInstance(L, 1) && CallIsA(L, 1, "ModuleScript"))
        {
            lua_pushvalue(L, 1);
            lua_pushcclosurek(L, RequireModuleClosure, nullptr, 1, nullptr);
            return 1;
        }

        lua_pushnil(L);
        return 1;
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "getscripts", Scripts::getscripts);
        Utils::AddFunction(L, "getrunningscripts", Scripts::getrunningscripts);
        Utils::AddFunction(L, "getscriptenv", Scripts::getscriptenv);
        Utils::AddFunction(L, "getscriptbytecode", Scripts::getscriptbytecode);
        Utils::AddFunction(L, "getscripthash", Scripts::getscripthash);
        Utils::AddFunction(L, "getscriptclosure", Scripts::getscriptclosure);
    }
}
