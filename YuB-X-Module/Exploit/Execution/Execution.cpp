#include <Exploit/Globals.hpp>
#include <Exploit/Execution/Execution.hpp>
#include <Exploit/TaskScheduler/TaskScheduler.hpp>

class bytecode_encoder : public Luau::BytecodeEncoder
{
    inline void encode(uint32_t* data, size_t count) override
    {
        for (auto i = 0; i < count;)
        {
            uint8_t opcode = LUAU_INSN_OP(data[i]);
            const auto lookup_table = reinterpret_cast<BYTE*>(offsets::opcode_lookup_table);
            uint8_t final_opcode = opcode * 227;
            final_opcode = lookup_table[final_opcode];

            data[i] = (final_opcode) | (data[i] & ~0xFF);
            i += Luau::getOpLength(static_cast<LuauOpcode>(opcode));
        }
    }
};

std::string execution::compile_script(const std::string& source)
{
    auto bytecode_encoding = bytecode_encoder();
    static const char* common_globals[] = { "Game", "Workspace", "game", "plugin", "script", "shared", "workspace", "_G", "_ENV", nullptr };

    Luau::CompileOptions options;
    options.debugLevel = 1;
    options.optimizationLevel = 1;
    options.mutableGlobals = common_globals;
    options.vectorLib = "Vector3";
    options.vectorCtor = "new";
    options.vectorType = "Vector3";

    return Luau::compile(source, options, {}, &bytecode_encoding);
}

void execution::execute_script(lua_State* L, const std::string& script)
{
    if (script.empty())
        return;

    int original_top = lua_gettop(L);
    lua_State* execution_thread = lua_newthread(L);
    lua_pop(L, 1);

    luaL_sandboxthread(execution_thread);
    task_scheduler::set_thread_capabilities(execution_thread, 8, max_capabilities);

    std::string bytecode = execution::compile_script(script);
    lua_pushcclosure(execution_thread, reinterpret_cast<lua_CFunction>(roblox::task_defer), 0, 0);
    if (luau_load(execution_thread, "", bytecode.c_str(), bytecode.length(), 0) != LUA_OK)
    {
        std::string error = lua_tostring(execution_thread, -1);
        roblox::print(3, "%s", error.c_str());
        lua_pop(execution_thread, 1);
        return;
    }

    Closure* closure = clvalue(luaA_toobject(execution_thread, -1));
    task_scheduler::set_proto_capabilities(closure->l.p, &max_capabilities);

    if (lua_pcall(execution_thread, 1, NULL, NULL) != LUA_OK)
    {
        std::string error = lua_tostring(execution_thread, -1);
        roblox::print(3, "%s", error.c_str());
        lua_pop(execution_thread, 1);
        return;
    }

    lua_settop(execution_thread, 0);
    lua_settop(L, original_top);
}
