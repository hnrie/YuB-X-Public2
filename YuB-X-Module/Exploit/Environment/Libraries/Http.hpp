#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <sstream>

#include <cpr/cpr.h>
#include <Exploit/Utils.hpp>
#include <Dependencies/nlohmann/json.hpp>
#include <Exploit/Environment/Yielding/Yielding.hpp>

enum request_methods
{
    h_get,
    h_head,
    h_post,
    h_put,
    h_delete,
    h_options
};

inline const std::map<std::string, request_methods> request_method_map = {
   { "get", h_get },
   { "head", h_head },
   { "post", h_post },
   { "put", h_put },
   { "delete", h_delete },
   { "options", h_options }
};

namespace http
{
    inline std::string get_game_field(lua_State* L, const char* field)
    {
        std::string value;
        lua_getglobal(L, "game");
        if (lua_istable(L, -1))
        {
            lua_getfield(L, -1, field);
            if (lua_isstring(L, -1))
                value = lua_tostring(L, -1);
            lua_pop(L, 1);
        }
        lua_pop(L, 1);
        return value;
    }

    int http_get(lua_State* L)
    {
        std::string url;

        if (!lua_isstring(L, 1))
        {
            luaL_checkstring(L, 2);
            url = lua_tostring(L, 2);
        }
        else
        {
            url = lua_tostring(L, 1);
        }

        if (url.find("http://") != 0 && url.find("https://") != 0)
        {
            luaL_argerror(L, 2, "invalid protocol (expected 'http://' or 'https://')");
            return 0;
        }

        std::string game_id = get_game_field(L, "GameId");
        std::string place_id = get_game_field(L, "PlaceId");

        HW_PROFILE_INFO hw_profile_info;
        std::string hwid = "Unknown";
        if (GetCurrentHwProfile(&hw_profile_info))
            hwid = hw_profile_info.szHwProfileGuid;

        using json = nlohmann::json;
        cpr::Header headers;
        json session_id_json;

        session_id_json["GameId"] = game_id;
        session_id_json["PlaceId"] = place_id;

        headers.insert({ "User-Agent", "Roblox/WinInet" });
        headers.insert({ "Roblox-Session-Id", session_id_json.dump() });
        headers.insert({ "Roblox-Place-Id", place_id });
        headers.insert({ "Roblox-Game-Id", game_id });
        headers.insert({ "Exploit-Identifier", "YuB-X-Public" });
        headers.insert({ "Exploit-Guid", hwid });
        headers.insert({ "YuB-X-Public-Fingerprint", hwid });
        headers.insert({ "Accept", "*/*" });

        return yielding::yield_execution(L, [url, headers]() -> std::function<int(lua_State*)>
        {
            cpr::Response result;
            try
            {
                result = cpr::Get(cpr::Url{ url }, cpr::Header(headers));
            }
            catch (const std::exception& ex)
            {
                std::string error_string = std::string("httpget failed: ") + ex.what();
                return [error_string](lua_State* L) -> int
                {
                    lua_pushstring(L, error_string.c_str());
                    return 1;
                };
            }
            catch (...)
            {
                return [](lua_State* L) -> int
                {
                    lua_pushstring(L, "httpget failed: unknown exception");
                    return 1;
                };
            }

            return [result, url](lua_State* L) -> int
            {
                if (result.error.code != cpr::ErrorCode::OK)
                {
                    std::string error_string = "httpget failed: " + result.error.message + ", code: " + std::to_string(result.status_code);
                    lua_pushstring(L, error_string.c_str());
                    return 1;
                }

                if (result.status_code != 200)
                {
                    std::string error_string = "httpget returned status: " + std::to_string(result.status_code) + ", error: " + result.error.message;
                    lua_pushstring(L, error_string.c_str());
                    return 1;
                }

                lua_pushlstring(L, result.text.data(), result.text.size());
                return 1;
            };
        });
    }

    int request(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TTABLE);

        lua_getfield(L, 1, "Url");
        if (!lua_isstring(L, -1))
            luaL_error(L, "missing or invalid 'url'");

        std::string url = lua_tostring(L, -1);
        lua_pop(L, 1);

        if (url.find("http://") != 0 && url.find("https://") != 0)
        {
            luaL_error(L, "invalid protocol (expected 'http://' or 'https://')");
            return 0;
        }

        auto method = h_get;
        lua_getfield(L, 1, "Method");
        if (lua_isstring(L, -1))
        {
            std::string method_str = lua_tostring(L, -1);
            std::transform(method_str.begin(), method_str.end(), method_str.begin(), ::tolower);
            auto it = request_method_map.find(method_str);
            if (it == request_method_map.end())
                luaL_error(L, "invalid request method: '%s'", method_str.c_str());
            method = it->second;
        }
        lua_pop(L, 1);

        cpr::Header headers;
        lua_getfield(L, 1, "Headers");
        if (lua_istable(L, -1))
        {
            lua_pushnil(L);
            while (lua_next(L, -2))
            {
                if (!lua_isstring(L, -2) || !lua_isstring(L, -1))
                    luaL_error(L, "'headers' must have string keys/values");
                std::string key = lua_tostring(L, -2);
                if (_stricmp(key.c_str(), "Content-Length") == 0)
                    luaL_error(L, "'content-length' cannot be overwritten");
                headers[key] = lua_tostring(L, -1);
                lua_pop(L, 1);
            }
        }
        lua_pop(L, 1);

        cpr::Cookies cookies;
        lua_getfield(L, 1, "Cookies");
        if (lua_istable(L, -1))
        {
            lua_pushnil(L);
            while (lua_next(L, -2))
            {
                if (!lua_isstring(L, -2) || !lua_isstring(L, -1))
                    luaL_error(L, "'cookies' must have string keys/values");
                cookies[lua_tostring(L, -2)] = lua_tostring(L, -1);
                lua_pop(L, 1);
            }
        }
        lua_pop(L, 1);

        std::string body;
        lua_getfield(L, 1, "Body");
        if (lua_isstring(L, -1))
        {
            if (method == h_get || method == h_head)
                luaL_error(L, "'body' is not allowed for get/head requests");
            body = lua_tostring(L, -1);
        }
        lua_pop(L, 1);

        std::string game_id = get_game_field(L, "GameId");
        std::string place_id = get_game_field(L, "PlaceId");

        HW_PROFILE_INFO hw_profile_info;
        std::string hwid = "Unknown";
        if (GetCurrentHwProfile(&hw_profile_info))
            hwid = hw_profile_info.szHwProfileGuid;

        nlohmann::json session_id_json;
        session_id_json["GameId"] = game_id;
        session_id_json["PlaceId"] = place_id;

        headers.insert({ "User-Agent", "YuB-X-Public"});
        headers.insert({ "Roblox-Session-Id", session_id_json.dump() });
        headers.insert({ "YuB-X-Public-Fingerprint", hwid });

        return yielding::yield_execution(L, [=]() -> std::function<int(lua_State*)>
        {
            cpr::Response response;
            try
            {
                switch (method)
                {
                    case h_get: response = cpr::Get(cpr::Url{ url }, cookies, headers); break;
                    case h_head: response = cpr::Head(cpr::Url{ url }, cookies, headers); break;
                    case h_post: response = cpr::Post(cpr::Url{ url }, cpr::Body{ body }, cookies, headers); break;
                    case h_put: response = cpr::Put(cpr::Url{ url }, cpr::Body{ body }, cookies, headers); break;
                    case h_delete: response = cpr::Delete(cpr::Url{ url }, cpr::Body{ body }, cookies, headers); break;
                    case h_options: response = cpr::Options(cpr::Url{ url }, cpr::Body{ body }, cookies, headers); break;
                    default: throw std::runtime_error("invalid request method"); break;
                }
            }
            catch (const std::exception& ex)
            {
                std::string err = std::string("request failed: ") + ex.what();
                return [err](lua_State* L) -> int
                {
                    lua_pushstring(L, err.c_str());
                    return 1;
                };
            }

            return [response](lua_State* L) -> int
            {
                if (response.error.code != cpr::ErrorCode::OK)
                {
                    std::string err = "request failed: " + response.error.message;
                    lua_pushstring(L, err.c_str());
                    return 1;
                }

                lua_newtable(L);

                lua_pushboolean(L, response.status_code >= 200 && response.status_code < 300);
                lua_setfield(L, -2, "Success");

                lua_pushinteger(L, response.status_code);
                lua_setfield(L, -2, "StatusCode");

                std::string phrase;
                switch (response.status_code)
                {
                    case 100: phrase = "Continue"; break;
                    case 101: phrase = "Switching Protocols"; break;
                    case 102: phrase = "Processing"; break;
                    case 103: phrase = "Early Hints"; break;

                    case 200: phrase = "OK"; break;
                    case 201: phrase = "Created"; break;
                    case 202: phrase = "Accepted"; break;
                    case 203: phrase = "Non-Authoritative Information"; break;
                    case 204: phrase = "No Content"; break;
                    case 205: phrase = "Reset Content"; break;
                    case 206: phrase = "Partial Content"; break;
                    case 207: phrase = "Multi-Status"; break;
                    case 208: phrase = "Already Reported"; break;
                    case 226: phrase = "IM Used"; break;

                    case 300: phrase = "Multiple Choices"; break;
                    case 301: phrase = "Moved Permanently"; break;
                    case 302: phrase = "Found"; break;
                    case 303: phrase = "See Other"; break;
                    case 304: phrase = "Not Modified"; break;
                    case 305: phrase = "Use Proxy"; break;
                    case 307: phrase = "Temporary Redirect"; break;
                    case 308: phrase = "Permanent Redirect"; break;

                    case 400: phrase = "Bad Request"; break;
                    case 401: phrase = "Unauthorized"; break;
                    case 402: phrase = "Payment Required"; break;
                    case 403: phrase = "Forbidden"; break;
                    case 404: phrase = "Not Found"; break;
                    case 405: phrase = "Method Not Allowed"; break;
                    case 406: phrase = "Not Acceptable"; break;
                    case 407: phrase = "Proxy Authentication Required"; break;
                    case 408: phrase = "Request Timeout"; break;
                    case 409: phrase = "Conflict"; break;
                    case 410: phrase = "Gone"; break;
                    case 411: phrase = "Length Required"; break;
                    case 412: phrase = "Precondition Failed"; break;
                    case 413: phrase = "Payload Too Large"; break;
                    case 414: phrase = "URI Too Long"; break;
                    case 415: phrase = "Unsupported Media Type"; break;
                    case 416: phrase = "Range Not Satisfiable"; break;
                    case 417: phrase = "Expectation Failed"; break;
                    case 418: phrase = "I'm a teapot"; break;
                    case 422: phrase = "Unprocessable Entity"; break;
                    case 423: phrase = "Locked"; break;
                    case 424: phrase = "Failed Dependency"; break;
                    case 426: phrase = "Upgrade Required"; break;
                    case 428: phrase = "Precondition Required"; break;
                    case 429: phrase = "Too Many Requests"; break;
                    case 431: phrase = "Request Header Fields Too Large"; break;
                    case 451: phrase = "Unavailable For Legal Reasons"; break;

                    case 500: phrase = "Internal Server Error"; break;
                    case 501: phrase = "Not Implemented"; break;
                    case 502: phrase = "Bad Gateway"; break;
                    case 503: phrase = "Service Unavailable"; break;
                    case 504: phrase = "Gateway Time-out"; break;
                    case 505: phrase = "HTTP Version Not Supported"; break;
                    case 506: phrase = "Variant Also Negotiates"; break;
                    case 507: phrase = "Insufficient Storage"; break;
                    case 508: phrase = "Loop Detected"; break;
                    case 510: phrase = "Not Extended"; break;
                    case 511: phrase = "Network Authentication Required"; break;

                    default: phrase = std::string(); break;
                }
                lua_pushstring(L, phrase.c_str());
                lua_setfield(L, -2, "StatusMessage");

                lua_newtable(L);
                for (auto& header : response.header)
                {
                    lua_pushstring(L, header.first.c_str());
                    lua_pushstring(L, header.second.c_str());
                    lua_settable(L, -3);
                }
                lua_setfield(L, -2, "Headers");

                lua_newtable(L);
                for (auto& c : response.cookies.map_)
                {
                    lua_pushstring(L, c.first.c_str());
                    lua_pushstring(L, c.second.c_str());
                    lua_settable(L, -3);
                }
                lua_setfield(L, -2, "Cookies");

                lua_pushlstring(L, response.text.data(), response.text.size());
                lua_setfield(L, -2, "Body");

                return 1;
            };
        });
    }

    void register_lib(lua_State* L)
    {
        utils::add_function(L, "HttpGet", http::http_get);
        utils::add_function(L, "request", http::request);
        utils::add_function(L, "http_request", http::request);

        lua_newtable(L);
        utils::add_table_function(L, "request", http::request);
        lua_setglobal(L, "http");
    }
}
