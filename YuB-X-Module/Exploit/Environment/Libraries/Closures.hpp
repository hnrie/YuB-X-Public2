#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <ldo.h>
#include <unordered_map>
#include <memory>
#include <functional>
#include <cstring>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>
#include <Exploit/Execution/Execution.hpp>
#include <Exploit/TaskScheduler/TaskScheduler.hpp>

namespace Closures
{
    struct HookedFunction
    {
        lua_CFunction original;
        bool isMetamethod;
        void* target;

        HookedFunction() : original(nullptr), isMetamethod(false), target(nullptr) {}
        HookedFunction(lua_CFunction orig, bool meta = false, void* tgt = nullptr)
            : original(orig), isMetamethod(meta), target(tgt) {}
    };

    inline std::unordered_map<void*, HookedFunction> HookedFunctions;
    inline std::unordered_map<void*, lua_CFunction> WrappedClosures;
    inline std::mutex HookMutex;

    int loadstring(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TSTRING);

        const char* ChunkName = luaL_optstring(L, 2, "");
        std::string Bytecode = Execution::CompileScript(lua_tostring(L, 1));
        if (luau_load(L, ChunkName, Bytecode.data(), Bytecode.size(), 0) != LUA_OK)
        {
            lua_pushnil(L);
            lua_pushvalue(L, -2);
            return 2;
        }

        Closure* Closure = clvalue(luaA_toobject(L, -1));
        TaskScheduler::SetProtoCapabilities(Closure->l.p, &MaxCapabilities);
        lua_setsafeenv(L, LUA_GLOBALSINDEX, false);

        return 1;
    }

    int checkcaller(lua_State* L)
    {
        lua_pushboolean(L, L == SharedVariables::ExploitThread);
        return 1;
    }

    int iscclosure(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if (!lua_isfunction(L, 1))
        {
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        Closure* closure = clvalue(luaA_toobject(L, 1));
        lua_pushboolean(L, closure->isC);
        return 1;
    }

    int islclosure(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if (!lua_isfunction(L, 1))
        {
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        Closure* closure = clvalue(luaA_toobject(L, 1));
        lua_pushboolean(L, !closure->isC);
        return 1;
    }

    int isexecutorclosure(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if (!lua_isfunction(L, 1))
        {
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        Closure* closure = clvalue(luaA_toobject(L, 1));
        
        if (!closure->isC)
        {
            lua_pushboolean(L, false);
            return 1;
        }

        lua_pushboolean(L, closure->c.f != nullptr);
        return 1;
    }

    static void CleanupClosure(void* p)
    {
        // Cleanup function for userdata dtor
    }

    int clonefunction(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* original = clvalue(luaA_toobject(L, 1));

        if (original->isC)
        {
            lua_pushcclosurek(L, original->c.f, nullptr, 0, nullptr);
        }
        else
        {
            if (!original->l.p)
            {
                luaL_error(L, "Cannot clone function without proto");
                return 0;
            }

            lua_newuserdatadtor(L, sizeof(Closure), CleanupClosure);

            Closure* newClosure = (Closure*)lua_touserdata(L, -1);
            memset(newClosure, 0, sizeof(Closure));
            newClosure->tt = LUA_TFUNCTION;
            newClosure->marked = 0;
            newClosure->isC = 0;
            newClosure->nupvalues = original->nupvalues;
            newClosure->stacksize = original->stacksize;
            newClosure->env = original->env;
            newClosure->l.p = original->l.p;

            for (int i = 0; i < original->nupvalues; i++)
            {
                setobj(L, &newClosure->l.uprefs[i], &original->l.uprefs[i]);
            }
        }

        return 1;
    }

    static int CClosureWrapper(lua_State* L)
    {
        Closure* caller = curr_func(L);
        if (!caller || !caller->isC)
        {
            luaL_error(L, "newcclosure can only be called from C");
            return 0;
        }

        const char* upvalue = lua_getupvalue(L, 1, 1);
        if (!upvalue)
        {
            luaL_error(L, "Invalid closure upvalue");
            return 0;
        }

        if (!lua_islightuserdata(L, -1))
        {
            lua_pop(L, 1);
            luaL_error(L, "Invalid closure upvalue type");
            return 0;
        }

        void* idPtr = lua_touserdata(L, -1);
        lua_pop(L, 1);

        if (!idPtr)
        {
            luaL_error(L, "Invalid closure id");
            return 0;
        }

        int id = static_cast<int>(reinterpret_cast<uintptr_t>(idPtr));

        std::lock_guard<std::mutex> lock(HookMutex);
        auto it = WrappedClosures.find(reinterpret_cast<void*>(static_cast<uintptr_t>(id)));
        if (it == WrappedClosures.end())
        {
            luaL_error(L, "Closure not found");
            return 0;
        }

        return it->second(L);
    }

    int newcclosure(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* funcClosure = clvalue(luaA_toobject(L, 1));

        if (!funcClosure->isC)
        {
            luaL_error(L, "expected C function, got Lua function");
            return 0;
        }

        lua_CFunction wrappedFunction = funcClosure->c.f;

        static int closureId = 0;
        int id = ++closureId;

        std::lock_guard<std::mutex> lock(HookMutex);
        WrappedClosures[reinterpret_cast<void*>(static_cast<uintptr_t>(id))] = wrappedFunction;

        lua_pushlightuserdata(L, reinterpret_cast<void*>(static_cast<uintptr_t>(id)));
        lua_pushcclosurek(L, CClosureWrapper, nullptr, 1, nullptr);

        return 1;
    }

    int hookfunction(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function for argument 1, got %s", lua_typename(L, lua_type(L, 1)));
        
        if (!lua_isfunction(L, 2))
            luaL_error(L, "expected function for argument 2, got %s", lua_typename(L, lua_type(L, 2)));

        Closure* originalClosure = clvalue(luaA_toobject(L, 1));
        Closure* hookClosure = clvalue(luaA_toobject(L, 2));

        std::lock_guard<std::mutex> lock(HookMutex);
        
        if (originalClosure->isC)
        {
            HookedFunctions[reinterpret_cast<void*>(originalClosure->c.f)] = 
                HookedFunction(originalClosure->c.f);
            originalClosure->c.f = hookClosure->c.f;
        }
        else
        {
            luaL_error(L, "Cannot hook Lua functions directly");
            return 0;
        }

        lua_pushvalue(L, 1);
        return 1;
    }

    int restorefunction(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* closure = clvalue(luaA_toobject(L, 1));

        std::lock_guard<std::mutex> lock(HookMutex);
        
        if (closure->isC)
        {
            auto it = HookedFunctions.find(reinterpret_cast<void*>(closure->c.f));
            if (it != HookedFunctions.end())
            {
                closure->c.f = it->second.original;
                HookedFunctions.erase(it);
                lua_pushboolean(L, true);
            }
            else
            {
                lua_pushboolean(L, false);
            }
        }
        else
        {
            lua_pushboolean(L, false);
        }

        return 1;
    }

    int hookmetamethod(lua_State* L)
    {
        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
            luaL_error(L, "expected table or userdata for argument 1, got %s", lua_typename(L, lua_type(L, 1)));
        
        if (!lua_isstring(L, 2))
            luaL_error(L, "expected string for argument 2, got %s", lua_typename(L, lua_type(L, 2)));
        
        if (!lua_isfunction(L, 3))
            luaL_error(L, "expected function for argument 3, got %s", lua_typename(L, lua_type(L, 2)));

        const char* metamethodName = lua_tostring(L, 2);
        
        if (!lua_getmetatable(L, 1))
        {
            lua_createtable(L, 0, 1);
            lua_setmetatable(L, 1);
            lua_getmetatable(L, 1);
        }

        lua_CFunction original = nullptr;
        if (lua_getfield(L, -1, metamethodName) == LUA_TFUNCTION)
        {
            original = lua_tocfunction(L, -1);
            lua_pop(L, 1);
        }
        else
        {
            lua_pop(L, 1);
        }

        Closure* hookClosure = clvalue(luaA_toobject(L, 3));
        
        std::lock_guard<std::mutex> lock(HookMutex);
        
        if (original)
        {
            HookedFunctions[reinterpret_cast<void*>(hookClosure->c.f)] =
                HookedFunction(original, true, nullptr);
        }

        lua_pushcclosurek(L, hookClosure->c.f, nullptr, 0, nullptr);
        lua_setfield(L, -2, metamethodName);

        lua_pop(L, 1);

        lua_pushvalue(L, 1);
        lua_pushstring(L, metamethodName);

        return 2;
    }

    int getfunctionhash(lua_State* L)
    {
        if (!lua_isfunction(L, 1))
            luaL_error(L, "expected function, got %s", lua_typename(L, lua_type(L, 1)));

        Closure* closure = clvalue(luaA_toobject(L, 1));
        
        uintptr_t hashValue = 0;
        if (closure->isC)
        {
            hashValue = reinterpret_cast<uintptr_t>(closure->c.f);
        }
        else
        {
            hashValue = reinterpret_cast<uintptr_t>(closure->l.p);
        }

        hashValue = (hashValue >> 4) ^ (hashValue << 5);
        hashValue = (hashValue >> 4) ^ (hashValue << 5);
        hashValue = (hashValue >> 4) ^ (hashValue << 5);
        hashValue = (hashValue >> 4) ^ (hashValue << 5);

        lua_pushinteger(L, static_cast<lua_Integer>(hashValue));
        return 1;
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "loadstring", Closures::loadstring);
        Utils::AddFunction(L, "checkcaller", Closures::checkcaller);
        Utils::AddFunction(L, "iscclosure", Closures::iscclosure);
        Utils::AddFunction(L, "islclosure", Closures::islclosure);
        Utils::AddFunction(L, "isexecutorclosure", Closures::isexecutorclosure);
        Utils::AddFunction(L, "clonefunction", Closures::clonefunction);
        Utils::AddFunction(L, "newcclosure", Closures::newcclosure);
        Utils::AddFunction(L, "hookfunction", Closures::hookfunction);
        Utils::AddFunction(L, "restorefunction", Closures::restorefunction);
        Utils::AddFunction(L, "hookmetamethod", Closures::hookmetamethod);
        Utils::AddFunction(L, "getfunctionhash", Closures::getfunctionhash);
    }
}
