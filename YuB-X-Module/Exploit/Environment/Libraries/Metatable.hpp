#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lualib.h>
#include <lobject.h>
#include <lgc.h>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>

namespace Metatable
{
    int getrawmetatable(lua_State* L)
    {
        luaL_checkany(L, 1);

        int t = lua_type(L, 1);

        if (t == LUA_TTABLE)
        {
            LuaTable* tbl = hvalue(luaA_toobject(L, 1));
            if (tbl)
            {
                LuaTable* mt = tbl->metatable;
                if (mt)
                {
                    sethvalue(L, L->top, mt);
                    L->top++;
                    return 1;
                }
            }
        }
        else if (t == LUA_TUSERDATA)
        {
            Udata* udata = uvalue(luaA_toobject(L, 1));
            if (udata)
            {
                LuaTable* mt = UDATA_META_DEC<LuaTable*>(udata->metatable);
                if (mt)
                {
                    sethvalue(L, L->top, mt);
                    L->top++;
                    return 1;
                }
            }
        }

        lua_pushnil(L);
        return 1;
    }

    int setrawmetatable(lua_State* L)
    {
        luaL_checkany(L, 1);
        luaL_checktype(L, 2, LUA_TTABLE);

        int t = lua_type(L, 1);
        LuaTable* mt = hvalue(luaA_toobject(L, 2));

        if (!mt)
        {
            lua_pushnil(L);
            return 1;
        }

        if (t == LUA_TTABLE)
        {
            LuaTable* tbl = hvalue(luaA_toobject(L, 1));
            if (tbl)
            {
                luaC_barriert(L, tbl, obj2gco(mt));
                tbl->metatable = mt;
                lua_pushvalue(L, 1);
                return 1;
            }
        }
        else if (t == LUA_TUSERDATA)
        {
            Udata* udata = uvalue(luaA_toobject(L, 1));
            if (udata)
            {
                luaC_objbarrier(L, udata, mt);
                UDATA_META_ENC<LuaTable*> newMeta = mt;
                udata->metatable = newMeta;
                lua_pushvalue(L, 1);
                return 1;
            }
        }

        lua_pushnil(L);
        return 1;
    }

    int setreadonly(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TTABLE);
        luaL_checktype(L, 2, LUA_TBOOLEAN);

        bool readonly = lua_toboolean(L, 2);
        lua_setreadonly(L, 1, readonly ? 1 : 0);
        
        return 0;
    }

    int isreadonly(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TTABLE);

        int readonly = lua_getreadonly(L, 1);
        lua_pushboolean(L, readonly != 0);
        
        return 1;
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "getrawmetatable", Metatable::getrawmetatable);
        Utils::AddFunction(L, "setrawmetatable", Metatable::setrawmetatable);
        Utils::AddFunction(L, "setreadonly", Metatable::setreadonly);
        Utils::AddFunction(L, "isreadonly", Metatable::isreadonly);
    }
}
