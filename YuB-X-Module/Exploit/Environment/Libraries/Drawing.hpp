#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <string>
#include <vector>
#include <unordered_map>
#include <memory>
#include <mutex>
#include <atomic>
#include <cmath>
#include <algorithm>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>

#include <Dependencies/imgui/imgui.h>
#include <Dependencies/imgui/imgui_internal.h>

namespace Drawing
{
    enum class DrawingType
    {
        Line,
        Text,
        Image,
        Circle,
        Square,
        Quad,
        Triangle
    };

    enum class DrawingFont
    {
        UI = 0,
        System = 1,
        Plex = 2,
        Monospace = 3
    };

    struct Color3
    {
        float R = 1.0f;
        float G = 1.0f;
        float B = 1.0f;
    };

    struct Vector2
    {
        float X = 0.0f;
        float Y = 0.0f;
    };

    struct DrawingObject
    {
        DrawingType Type;
        bool Visible = false;
        int ZIndex = 0;
        float Transparency = 0.0f;
        Color3 Color;
        bool Exists = true;

        virtual ~DrawingObject() = default;
        virtual void Render(ImDrawList* DrawList) = 0;
    };

    struct LineObject : DrawingObject
    {
        Vector2 From;
        Vector2 To;
        float Thickness = 1.0f;

        LineObject() { Type = DrawingType::Line; }

        void Render(ImDrawList* DrawList) override
        {
            if (!Visible || !Exists) return;
            float Alpha = 1.0f - Transparency;
            if (Alpha <= 0.0f) return;
            ImU32 Col = IM_COL32(
                static_cast<int>(Color.R * 255),
                static_cast<int>(Color.G * 255),
                static_cast<int>(Color.B * 255),
                static_cast<int>(Alpha * 255)
            );
            DrawList->AddLine(ImVec2(From.X, From.Y), ImVec2(To.X, To.Y), Col, Thickness);
        }
    };

    struct TextObject : DrawingObject
    {
        std::string Text;
        Vector2 TextBounds;
        DrawingFont Font = DrawingFont::UI;
        float Size = 13.0f;
        Vector2 Position;
        bool Center = false;
        bool Outline = false;
        Color3 OutlineColor;

        TextObject() { Type = DrawingType::Text; }

        void Render(ImDrawList* DrawList) override
        {
            if (!Visible || !Exists || Text.empty()) return;
            float Alpha = 1.0f - Transparency;
            if (Alpha <= 0.0f) return;

            ImFont* ImGuiFont = ImGui::GetIO().Fonts->Fonts.empty() ? nullptr : ImGui::GetIO().Fonts->Fonts[0];
            ImVec2 TextSize = ImGui::CalcTextSize(Text.c_str());
            TextBounds.X = TextSize.x;
            TextBounds.Y = TextSize.y;

            ImVec2 DrawPos(Position.X, Position.Y);
            if (Center)
                DrawPos.x -= TextSize.x * 0.5f;

            ImU32 Col = IM_COL32(
                static_cast<int>(Color.R * 255),
                static_cast<int>(Color.G * 255),
                static_cast<int>(Color.B * 255),
                static_cast<int>(Alpha * 255)
            );

            if (Outline)
            {
                float OutlineAlpha = 1.0f - Transparency;
                ImU32 OutCol = IM_COL32(
                    static_cast<int>(OutlineColor.R * 255),
                    static_cast<int>(OutlineColor.G * 255),
                    static_cast<int>(OutlineColor.B * 255),
                    static_cast<int>(OutlineAlpha * 255)
                );
                DrawList->AddText(ImGuiFont, Size, ImVec2(DrawPos.x - 1, DrawPos.y - 1), OutCol, Text.c_str());
                DrawList->AddText(ImGuiFont, Size, ImVec2(DrawPos.x + 1, DrawPos.y - 1), OutCol, Text.c_str());
                DrawList->AddText(ImGuiFont, Size, ImVec2(DrawPos.x - 1, DrawPos.y + 1), OutCol, Text.c_str());
                DrawList->AddText(ImGuiFont, Size, ImVec2(DrawPos.x + 1, DrawPos.y + 1), OutCol, Text.c_str());
            }

            DrawList->AddText(ImGuiFont, Size, DrawPos, Col, Text.c_str());
        }
    };

    struct ImageObject : DrawingObject
    {
        std::string Data;
        Vector2 Size;
        Vector2 Position;
        float Rounding = 0.0f;
        ImTextureID TextureID = (ImTextureID)0;
        bool TextureDirty = false;

        ImageObject() { Type = DrawingType::Image; }

        void Render(ImDrawList* DrawList) override
        {
            if (!Visible || !Exists || !TextureID) return;
            float Alpha = 1.0f - Transparency;
            if (Alpha <= 0.0f) return;

            ImU32 Col = IM_COL32(255, 255, 255, static_cast<int>(Alpha * 255));
            ImVec2 Min(Position.X, Position.Y);
            ImVec2 Max(Position.X + Size.X, Position.Y + Size.Y);

            if (Rounding > 0.0f)
                DrawList->AddImageRounded(TextureID, Min, Max, ImVec2(0, 0), ImVec2(1, 1), Col, Rounding);
            else
                DrawList->AddImage(TextureID, Min, Max, ImVec2(0, 0), ImVec2(1, 1), Col);
        }
    };

    struct CircleObject : DrawingObject
    {
        int NumSides = 64;
        float Radius = 10.0f;
        Vector2 Position;
        float Thickness = 1.0f;
        bool Filled = false;

        CircleObject() { Type = DrawingType::Circle; }

        void Render(ImDrawList* DrawList) override
        {
            if (!Visible || !Exists || Radius <= 0.0f) return;
            float Alpha = 1.0f - Transparency;
            if (Alpha <= 0.0f) return;

            ImU32 Col = IM_COL32(
                static_cast<int>(Color.R * 255),
                static_cast<int>(Color.G * 255),
                static_cast<int>(Color.B * 255),
                static_cast<int>(Alpha * 255)
            );
            int Segments = (std::max)(3, NumSides);
            if (Filled)
                DrawList->AddCircleFilled(ImVec2(Position.X, Position.Y), Radius, Col, Segments);
            else
                DrawList->AddCircle(ImVec2(Position.X, Position.Y), Radius, Col, Segments, Thickness);
        }
    };

    struct SquareObject : DrawingObject
    {
        Vector2 Size;
        Vector2 Position;
        float Thickness = 1.0f;
        bool Filled = false;

        SquareObject() { Type = DrawingType::Square; }

        void Render(ImDrawList* DrawList) override
        {
            if (!Visible || !Exists) return;
            float Alpha = 1.0f - Transparency;
            if (Alpha <= 0.0f) return;

            ImU32 Col = IM_COL32(
                static_cast<int>(Color.R * 255),
                static_cast<int>(Color.G * 255),
                static_cast<int>(Color.B * 255),
                static_cast<int>(Alpha * 255)
            );
            ImVec2 Min(Position.X, Position.Y);
            ImVec2 Max(Position.X + Size.X, Position.Y + Size.Y);
            if (Filled)
                DrawList->AddRectFilled(Min, Max, Col);
            else
                DrawList->AddRect(Min, Max, Col, 0.0f, 0, Thickness);
        }
    };

    struct QuadObject : DrawingObject
    {
        Vector2 PointA;
        Vector2 PointB;
        Vector2 PointC;
        Vector2 PointD;
        float Thickness = 1.0f;
        bool Filled = false;

        QuadObject() { Type = DrawingType::Quad; }

        void Render(ImDrawList* DrawList) override
        {
            if (!Visible || !Exists) return;
            float Alpha = 1.0f - Transparency;
            if (Alpha <= 0.0f) return;

            ImU32 Col = IM_COL32(
                static_cast<int>(Color.R * 255),
                static_cast<int>(Color.G * 255),
                static_cast<int>(Color.B * 255),
                static_cast<int>(Alpha * 255)
            );
            ImVec2 A(PointA.X, PointA.Y);
            ImVec2 B(PointB.X, PointB.Y);
            ImVec2 C(PointC.X, PointC.Y);
            ImVec2 D(PointD.X, PointD.Y);
            if (Filled)
            {
                DrawList->AddTriangleFilled(A, B, C, Col);
                DrawList->AddTriangleFilled(A, C, D, Col);
            }
            else
            {
                DrawList->AddQuad(A, B, C, D, Col, Thickness);
            }
        }
    };

    struct TriangleObject : DrawingObject
    {
        Vector2 PointA;
        Vector2 PointB;
        Vector2 PointC;
        float Thickness = 1.0f;
        bool Filled = false;

        TriangleObject() { Type = DrawingType::Triangle; }

        void Render(ImDrawList* DrawList) override
        {
            if (!Visible || !Exists) return;
            float Alpha = 1.0f - Transparency;
            if (Alpha <= 0.0f) return;

            ImU32 Col = IM_COL32(
                static_cast<int>(Color.R * 255),
                static_cast<int>(Color.G * 255),
                static_cast<int>(Color.B * 255),
                static_cast<int>(Alpha * 255)
            );
            ImVec2 A(PointA.X, PointA.Y);
            ImVec2 B(PointB.X, PointB.Y);
            ImVec2 C(PointC.X, PointC.Y);
            if (Filled)
                DrawList->AddTriangleFilled(A, B, C, Col);
            else
                DrawList->AddTriangle(A, B, C, Col, Thickness);
        }
    };

    inline std::mutex ObjectMutex;
    inline std::unordered_map<uintptr_t, std::shared_ptr<DrawingObject>> ObjectRegistry;
    inline std::atomic<uintptr_t> NextObjectId{ 1 };

    inline uintptr_t RegisterObject(std::shared_ptr<DrawingObject> Obj)
    {
        std::lock_guard<std::mutex> Lock(ObjectMutex);
        uintptr_t Id = NextObjectId.fetch_add(1);
        ObjectRegistry[Id] = std::move(Obj);
        return Id;
    }

    inline std::shared_ptr<DrawingObject> GetObject(uintptr_t Id)
    {
        std::lock_guard<std::mutex> Lock(ObjectMutex);
        auto It = ObjectRegistry.find(Id);
        if (It != ObjectRegistry.end())
            return It->second;
        return nullptr;
    }

    inline void RemoveObject(uintptr_t Id)
    {
        std::lock_guard<std::mutex> Lock(ObjectMutex);
        ObjectRegistry.erase(Id);
    }

    inline void ClearAllObjects()
    {
        std::lock_guard<std::mutex> Lock(ObjectMutex);
        for (auto& Pair : ObjectRegistry)
            Pair.second->Exists = false;
        ObjectRegistry.clear();
    }

    inline void RenderAll(ImDrawList* DrawList)
    {
        std::lock_guard<std::mutex> Lock(ObjectMutex);
        std::vector<std::pair<int, DrawingObject*>> Sorted;
        Sorted.reserve(ObjectRegistry.size());
        for (auto& Pair : ObjectRegistry)
            Sorted.push_back({ Pair.second->ZIndex, Pair.second.get() });
        std::stable_sort(Sorted.begin(), Sorted.end(), [](const auto& A, const auto& B) {
            return A.first < B.first;
        });
        for (auto& Entry : Sorted)
            Entry.second->Render(DrawList);
    }

    static int PushVector2(lua_State* L, float X, float Y)
    {
        lua_newtable(L);
        lua_pushnumber(L, X);
        lua_setfield(L, -2, "X");
        lua_pushnumber(L, Y);
        lua_setfield(L, -2, "Y");
        return 1;
    }

    static bool ReadVector2(lua_State* L, int Idx, float& X, float& Y)
    {
        if (!lua_istable(L, Idx)) return false;
        lua_getfield(L, Idx, "X");
        X = static_cast<float>(lua_tonumber(L, -1));
        lua_pop(L, 1);
        lua_getfield(L, Idx, "Y");
        Y = static_cast<float>(lua_tonumber(L, -1));
        lua_pop(L, 1);
        return true;
    }

    static bool ReadColor3(lua_State* L, int Idx, Color3& Out)
    {
        if (!lua_istable(L, Idx)) return false;
        lua_getfield(L, Idx, "R");
        Out.R = static_cast<float>(lua_tonumber(L, -1));
        lua_pop(L, 1);
        lua_getfield(L, Idx, "G");
        Out.G = static_cast<float>(lua_tonumber(L, -1));
        lua_pop(L, 1);
        lua_getfield(L, Idx, "B");
        Out.B = static_cast<float>(lua_tonumber(L, -1));
        lua_pop(L, 1);
        return true;
    }

    static void PushColor3(lua_State* L, const Color3& C)
    {
        lua_newtable(L);
        lua_pushnumber(L, C.R);
        lua_setfield(L, -2, "R");
        lua_pushnumber(L, C.G);
        lua_setfield(L, -2, "G");
        lua_pushnumber(L, C.B);
        lua_setfield(L, -2, "B");
    }

    static uintptr_t GetObjectId(lua_State* L, int Idx)
    {
        if (!lua_istable(L, Idx)) return 0;
        lua_getfield(L, Idx, "__id");
        uintptr_t Id = static_cast<uintptr_t>(lua_tointeger(L, -1));
        lua_pop(L, 1);
        return Id;
    }

    static int DrawingIndex(lua_State* L)
    {
        uintptr_t Id = GetObjectId(L, 1);
        if (!Id) { lua_pushnil(L); return 1; }

        auto Obj = GetObject(Id);
        if (!Obj) { lua_pushnil(L); return 1; }

        const char* Key = luaL_checkstring(L, 2);

        if (strcmp(Key, "__OBJECT_EXISTS") == 0) { lua_pushboolean(L, Obj->Exists ? 1 : 0); return 1; }
        if (strcmp(Key, "Visible") == 0) { lua_pushboolean(L, Obj->Visible ? 1 : 0); return 1; }
        if (strcmp(Key, "ZIndex") == 0) { lua_pushnumber(L, Obj->ZIndex); return 1; }
        if (strcmp(Key, "Transparency") == 0) { lua_pushnumber(L, Obj->Transparency); return 1; }
        if (strcmp(Key, "Color") == 0) { PushColor3(L, Obj->Color); return 1; }

        if (strcmp(Key, "Destroy") == 0)
        {
            lua_pushcclosurek(L, [](lua_State* State) -> int {
                uintptr_t ObjId = GetObjectId(State, 1);
                if (!ObjId) return 0;
                auto Target = GetObject(ObjId);
                if (Target)
                {
                    Target->Exists = false;
                    Target->Visible = false;
                }
                RemoveObject(ObjId);
                lua_pushboolean(State, 1);
                lua_setfield(State, 1, "__OBJECT_EXISTS");
                return 0;
            }, nullptr, 0, nullptr);
            return 1;
        }

        switch (Obj->Type)
        {
        case DrawingType::Line:
        {
            auto* O = static_cast<LineObject*>(Obj.get());
            if (strcmp(Key, "From") == 0) { PushVector2(L, O->From.X, O->From.Y); return 1; }
            if (strcmp(Key, "To") == 0) { PushVector2(L, O->To.X, O->To.Y); return 1; }
            if (strcmp(Key, "Thickness") == 0) { lua_pushnumber(L, O->Thickness); return 1; }
            break;
        }
        case DrawingType::Text:
        {
            auto* O = static_cast<TextObject*>(Obj.get());
            if (strcmp(Key, "Text") == 0) { lua_pushstring(L, O->Text.c_str()); return 1; }
            if (strcmp(Key, "TextBounds") == 0) { PushVector2(L, O->TextBounds.X, O->TextBounds.Y); return 1; }
            if (strcmp(Key, "Font") == 0) { lua_pushnumber(L, static_cast<int>(O->Font)); return 1; }
            if (strcmp(Key, "Size") == 0) { lua_pushnumber(L, O->Size); return 1; }
            if (strcmp(Key, "Position") == 0) { PushVector2(L, O->Position.X, O->Position.Y); return 1; }
            if (strcmp(Key, "Center") == 0) { lua_pushboolean(L, O->Center ? 1 : 0); return 1; }
            if (strcmp(Key, "Outline") == 0) { lua_pushboolean(L, O->Outline ? 1 : 0); return 1; }
            if (strcmp(Key, "OutlineColor") == 0) { PushColor3(L, O->OutlineColor); return 1; }
            break;
        }
        case DrawingType::Image:
        {
            auto* O = static_cast<ImageObject*>(Obj.get());
            if (strcmp(Key, "Data") == 0) { lua_pushlstring(L, O->Data.c_str(), O->Data.size()); return 1; }
            if (strcmp(Key, "Size") == 0) { PushVector2(L, O->Size.X, O->Size.Y); return 1; }
            if (strcmp(Key, "Position") == 0) { PushVector2(L, O->Position.X, O->Position.Y); return 1; }
            if (strcmp(Key, "Rounding") == 0) { lua_pushnumber(L, O->Rounding); return 1; }
            break;
        }
        case DrawingType::Circle:
        {
            auto* O = static_cast<CircleObject*>(Obj.get());
            if (strcmp(Key, "NumSides") == 0) { lua_pushnumber(L, O->NumSides); return 1; }
            if (strcmp(Key, "Radius") == 0) { lua_pushnumber(L, O->Radius); return 1; }
            if (strcmp(Key, "Position") == 0) { PushVector2(L, O->Position.X, O->Position.Y); return 1; }
            if (strcmp(Key, "Thickness") == 0) { lua_pushnumber(L, O->Thickness); return 1; }
            if (strcmp(Key, "Filled") == 0) { lua_pushboolean(L, O->Filled ? 1 : 0); return 1; }
            break;
        }
        case DrawingType::Square:
        {
            auto* O = static_cast<SquareObject*>(Obj.get());
            if (strcmp(Key, "Size") == 0) { PushVector2(L, O->Size.X, O->Size.Y); return 1; }
            if (strcmp(Key, "Position") == 0) { PushVector2(L, O->Position.X, O->Position.Y); return 1; }
            if (strcmp(Key, "Thickness") == 0) { lua_pushnumber(L, O->Thickness); return 1; }
            if (strcmp(Key, "Filled") == 0) { lua_pushboolean(L, O->Filled ? 1 : 0); return 1; }
            break;
        }
        case DrawingType::Quad:
        {
            auto* O = static_cast<QuadObject*>(Obj.get());
            if (strcmp(Key, "PointA") == 0) { PushVector2(L, O->PointA.X, O->PointA.Y); return 1; }
            if (strcmp(Key, "PointB") == 0) { PushVector2(L, O->PointB.X, O->PointB.Y); return 1; }
            if (strcmp(Key, "PointC") == 0) { PushVector2(L, O->PointC.X, O->PointC.Y); return 1; }
            if (strcmp(Key, "PointD") == 0) { PushVector2(L, O->PointD.X, O->PointD.Y); return 1; }
            if (strcmp(Key, "Thickness") == 0) { lua_pushnumber(L, O->Thickness); return 1; }
            if (strcmp(Key, "Filled") == 0) { lua_pushboolean(L, O->Filled ? 1 : 0); return 1; }
            break;
        }
        case DrawingType::Triangle:
        {
            auto* O = static_cast<TriangleObject*>(Obj.get());
            if (strcmp(Key, "PointA") == 0) { PushVector2(L, O->PointA.X, O->PointA.Y); return 1; }
            if (strcmp(Key, "PointB") == 0) { PushVector2(L, O->PointB.X, O->PointB.Y); return 1; }
            if (strcmp(Key, "PointC") == 0) { PushVector2(L, O->PointC.X, O->PointC.Y); return 1; }
            if (strcmp(Key, "Thickness") == 0) { lua_pushnumber(L, O->Thickness); return 1; }
            if (strcmp(Key, "Filled") == 0) { lua_pushboolean(L, O->Filled ? 1 : 0); return 1; }
            break;
        }
        }

        lua_pushnil(L);
        return 1;
    }

    static int DrawingNewIndex(lua_State* L)
    {
        uintptr_t Id = GetObjectId(L, 1);
        if (!Id) return 0;

        auto Obj = GetObject(Id);
        if (!Obj) return 0;

        const char* Key = luaL_checkstring(L, 2);

        if (strcmp(Key, "Visible") == 0) { Obj->Visible = lua_toboolean(L, 3) != 0; return 0; }
        if (strcmp(Key, "ZIndex") == 0) { Obj->ZIndex = static_cast<int>(lua_tonumber(L, 3)); return 0; }
        if (strcmp(Key, "Transparency") == 0) { Obj->Transparency = static_cast<float>(lua_tonumber(L, 3)); return 0; }
        if (strcmp(Key, "Color") == 0) { ReadColor3(L, 3, Obj->Color); return 0; }

        switch (Obj->Type)
        {
        case DrawingType::Line:
        {
            auto* O = static_cast<LineObject*>(Obj.get());
            if (strcmp(Key, "From") == 0) { ReadVector2(L, 3, O->From.X, O->From.Y); return 0; }
            if (strcmp(Key, "To") == 0) { ReadVector2(L, 3, O->To.X, O->To.Y); return 0; }
            if (strcmp(Key, "Thickness") == 0) { O->Thickness = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            break;
        }
        case DrawingType::Text:
        {
            auto* O = static_cast<TextObject*>(Obj.get());
            if (strcmp(Key, "Text") == 0) { O->Text = lua_isstring(L, 3) ? lua_tostring(L, 3) : ""; return 0; }
            if (strcmp(Key, "Font") == 0) { O->Font = static_cast<DrawingFont>(static_cast<int>(lua_tonumber(L, 3))); return 0; }
            if (strcmp(Key, "Size") == 0) { O->Size = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            if (strcmp(Key, "Position") == 0) { ReadVector2(L, 3, O->Position.X, O->Position.Y); return 0; }
            if (strcmp(Key, "Center") == 0) { O->Center = lua_toboolean(L, 3) != 0; return 0; }
            if (strcmp(Key, "Outline") == 0) { O->Outline = lua_toboolean(L, 3) != 0; return 0; }
            if (strcmp(Key, "OutlineColor") == 0) { ReadColor3(L, 3, O->OutlineColor); return 0; }
            break;
        }
        case DrawingType::Image:
        {
            auto* O = static_cast<ImageObject*>(Obj.get());
            if (strcmp(Key, "Data") == 0)
            {
                if (lua_isstring(L, 3))
                {
                    size_t Len = 0;
                    const char* Ptr = lua_tolstring(L, 3, &Len);
                    O->Data = std::string(Ptr, Len);
                    O->TextureDirty = true;
                }
                return 0;
            }
            if (strcmp(Key, "Size") == 0) { ReadVector2(L, 3, O->Size.X, O->Size.Y); return 0; }
            if (strcmp(Key, "Position") == 0) { ReadVector2(L, 3, O->Position.X, O->Position.Y); return 0; }
            if (strcmp(Key, "Rounding") == 0) { O->Rounding = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            break;
        }
        case DrawingType::Circle:
        {
            auto* O = static_cast<CircleObject*>(Obj.get());
            if (strcmp(Key, "NumSides") == 0) { O->NumSides = static_cast<int>(lua_tonumber(L, 3)); return 0; }
            if (strcmp(Key, "Radius") == 0) { O->Radius = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            if (strcmp(Key, "Position") == 0) { ReadVector2(L, 3, O->Position.X, O->Position.Y); return 0; }
            if (strcmp(Key, "Thickness") == 0) { O->Thickness = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            if (strcmp(Key, "Filled") == 0) { O->Filled = lua_toboolean(L, 3) != 0; return 0; }
            break;
        }
        case DrawingType::Square:
        {
            auto* O = static_cast<SquareObject*>(Obj.get());
            if (strcmp(Key, "Size") == 0) { ReadVector2(L, 3, O->Size.X, O->Size.Y); return 0; }
            if (strcmp(Key, "Position") == 0) { ReadVector2(L, 3, O->Position.X, O->Position.Y); return 0; }
            if (strcmp(Key, "Thickness") == 0) { O->Thickness = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            if (strcmp(Key, "Filled") == 0) { O->Filled = lua_toboolean(L, 3) != 0; return 0; }
            break;
        }
        case DrawingType::Quad:
        {
            auto* O = static_cast<QuadObject*>(Obj.get());
            if (strcmp(Key, "PointA") == 0) { ReadVector2(L, 3, O->PointA.X, O->PointA.Y); return 0; }
            if (strcmp(Key, "PointB") == 0) { ReadVector2(L, 3, O->PointB.X, O->PointB.Y); return 0; }
            if (strcmp(Key, "PointC") == 0) { ReadVector2(L, 3, O->PointC.X, O->PointC.Y); return 0; }
            if (strcmp(Key, "PointD") == 0) { ReadVector2(L, 3, O->PointD.X, O->PointD.Y); return 0; }
            if (strcmp(Key, "Thickness") == 0) { O->Thickness = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            if (strcmp(Key, "Filled") == 0) { O->Filled = lua_toboolean(L, 3) != 0; return 0; }
            break;
        }
        case DrawingType::Triangle:
        {
            auto* O = static_cast<TriangleObject*>(Obj.get());
            if (strcmp(Key, "PointA") == 0) { ReadVector2(L, 3, O->PointA.X, O->PointA.Y); return 0; }
            if (strcmp(Key, "PointB") == 0) { ReadVector2(L, 3, O->PointB.X, O->PointB.Y); return 0; }
            if (strcmp(Key, "PointC") == 0) { ReadVector2(L, 3, O->PointC.X, O->PointC.Y); return 0; }
            if (strcmp(Key, "Thickness") == 0) { O->Thickness = static_cast<float>(lua_tonumber(L, 3)); return 0; }
            if (strcmp(Key, "Filled") == 0) { O->Filled = lua_toboolean(L, 3) != 0; return 0; }
            break;
        }
        }

        return 0;
    }

    static void PushDrawingObject(lua_State* L, uintptr_t Id)
    {
        lua_newtable(L);

        lua_pushinteger(L, static_cast<lua_Integer>(Id));
        lua_setfield(L, -2, "__id");

        lua_pushboolean(L, 1);
        lua_setfield(L, -2, "__OBJECT_EXISTS");

        lua_newtable(L);

        lua_pushcclosure(L, DrawingIndex, nullptr, 0);
        lua_setfield(L, -2, "__index");

        lua_pushcclosure(L, DrawingNewIndex, nullptr, 0);
        lua_setfield(L, -2, "__newindex");

        lua_pushstring(L, "Drawing");
        lua_setfield(L, -2, "__type");

        lua_setmetatable(L, -2);
    }

    int DrawingNew(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TSTRING);
        const char* TypeStr = lua_tostring(L, 1);

        std::shared_ptr<DrawingObject> Obj;

        if (strcmp(TypeStr, "Line") == 0)
            Obj = std::make_shared<LineObject>();
        else if (strcmp(TypeStr, "Text") == 0)
            Obj = std::make_shared<TextObject>();
        else if (strcmp(TypeStr, "Image") == 0)
            Obj = std::make_shared<ImageObject>();
        else if (strcmp(TypeStr, "Circle") == 0)
            Obj = std::make_shared<CircleObject>();
        else if (strcmp(TypeStr, "Square") == 0)
            Obj = std::make_shared<SquareObject>();
        else if (strcmp(TypeStr, "Quad") == 0)
            Obj = std::make_shared<QuadObject>();
        else if (strcmp(TypeStr, "Triangle") == 0)
            Obj = std::make_shared<TriangleObject>();
        else
            luaL_argerror(L, 1, "invalid drawing type; expected Line, Text, Image, Circle, Square, Quad, or Triangle");

        uintptr_t Id = RegisterObject(std::move(Obj));
        PushDrawingObject(L, Id);
        return 1;
    }

    int cleardrawcache(lua_State* L)
    {
        ClearAllObjects();
        return 0;
    }

    int isrenderobj(lua_State* L)
    {
        if (!lua_istable(L, 1))
        {
            lua_pushboolean(L, 0);
            return 1;
        }
        lua_getfield(L, 1, "__id");
        bool HasId = !lua_isnil(L, -1);
        lua_pop(L, 1);

        if (!HasId)
        {
            lua_pushboolean(L, 0);
            return 1;
        }

        uintptr_t Id = GetObjectId(L, 1);
        auto Obj = GetObject(Id);
        lua_pushboolean(L, (Obj && Obj->Exists) ? 1 : 0);
        return 1;
    }

    int getrenderproperty(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TTABLE);
        luaL_checktype(L, 2, LUA_TSTRING);

        lua_getfield(L, 1, "__id");
        bool HasId = !lua_isnil(L, -1);
        lua_pop(L, 1);

        if (!HasId)
        {
            lua_pushnil(L);
            return 1;
        }

        lua_pushvalue(L, 2);
        return DrawingIndex(L);
    }

    int setrenderproperty(lua_State* L)
    {
        luaL_checktype(L, 1, LUA_TTABLE);
        luaL_checktype(L, 2, LUA_TSTRING);

        lua_getfield(L, 1, "__id");
        bool HasId = !lua_isnil(L, -1);
        lua_pop(L, 1);

        if (!HasId) return 0;

        return DrawingNewIndex(L);
    }

    void RegisterLibrary(lua_State* L)
    {
        lua_newtable(L);

        lua_pushcclosure(L, DrawingNew, nullptr, 0);
        lua_setfield(L, -2, "new");

        lua_newtable(L);
        lua_pushnumber(L, static_cast<int>(DrawingFont::UI));
        lua_setfield(L, -2, "UI");
        lua_pushnumber(L, static_cast<int>(DrawingFont::System));
        lua_setfield(L, -2, "System");
        lua_pushnumber(L, static_cast<int>(DrawingFont::Plex));
        lua_setfield(L, -2, "Plex");
        lua_pushnumber(L, static_cast<int>(DrawingFont::Monospace));
        lua_setfield(L, -2, "Monospace");
        lua_setfield(L, -2, "Font");

        lua_setglobal(L, "Drawing");

        Utils::AddFunction(L, "cleardrawcache", Drawing::cleardrawcache);
        Utils::AddFunction(L, "isrenderobj", Drawing::isrenderobj);
        Utils::AddFunction(L, "getrenderproperty", Drawing::getrenderproperty);
        Utils::AddFunction(L, "setrenderproperty", Drawing::setrenderproperty);
    }
}
