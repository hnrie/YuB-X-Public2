#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <unordered_map>
#include <vector>
#include <cstring>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>
#include <lapi.h>
#include <lfunc.h>
#include <lobject.h>

namespace Debug
{
    static Closure* GetClosureFromArg(lua_State* L, int arg)
    {
        if (lua_isfunction(L, arg))
        {
            return clvalue(luaA_toobject(L, arg));
        }
        else if (lua_isnumber(L, arg))
        {
            int level = (int)lua_tointeger(L, arg);
            if (level < 0)
            {
                int absIndex = -level;
                if (absIndex > lua_gettop(L))
                    luaL_error(L, "invalid stack level");
                
                StkId func = L->top + level;
                if (!ttisfunction(func))
                    luaL_error(L, "function expected at stack level");
                
                return clvalue(func);
            }
            
            if (unsigned(level) >= unsigned(L->ci - L->base_ci))
                luaL_error(L, "invalid stack level");
            
            CallInfo* ci = L->ci - level;
            if (!ttisfunction(ci->func))
                luaL_error(L, "invalid stack level");
            
            return clvalue(ci->func);
        }
        
        luaL_error(L, "expected function or level, got %s", lua_typename(L, lua_type(L, arg)));
        return nullptr;
    }

    static void PushTValue(lua_State* L, const TValue* value)
    {
        switch (ttype(value))
        {
            case LUA_TNIL:
                lua_pushnil(L);
                break;
            case LUA_TBOOLEAN:
                lua_pushboolean(L, bvalue(value));
                break;
            case LUA_TNUMBER:
                lua_pushnumber(L, nvalue(value));
                break;
            case LUA_TSTRING:
                lua_pushstring(L, svalue(value));
                break;
            case LUA_TFUNCTION:
                setclvalue(L, L->top, clvalue(value));
                incr_top(L);
                break;
            case LUA_TTABLE:
                sethvalue(L, L->top, hvalue(value));
                incr_top(L);
                break;
            case LUA_TUSERDATA:
                lua_pushlightuserdata(L, pvalue(value));
                break;
            case LUA_TLIGHTUSERDATA:
                lua_pushlightuserdata(L, pvalue(value));
                break;
            case LUA_TTHREAD:
                setthvalue(L, L->top, thvalue(value));
                incr_top(L);
                break;
            case LUA_TVECTOR:
                lua_pushvector(L, vvalue(value)[0], vvalue(value)[1], vvalue(value)[2]);
                break;
            case LUA_TBUFFER:
                setbufvalue(L, L->top, bufvalue(value));
                incr_top(L);
                break;
            default:
                lua_pushnil(L);
                break;
        }
    }

    int getconstant(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        int index = (int)luaL_checkinteger(L, 2);
        
        Proto* p = cl->l.p;
        if (index < 1 || index > p->sizek)
        {
            lua_pushnil(L);
            return 1;
        }
        
        luaC_threadbarrier(L);
        PushTValue(L, &p->k[index - 1]);
        return 1;
    }

    int getconstants(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        Proto* p = cl->l.p;
        
        lua_createtable(L, p->sizek, 0);
        
        for (int i = 0; i < p->sizek; i++)
        {
            luaC_threadbarrier(L);
            PushTValue(L, &p->k[i]);
            lua_rawseti(L, -2, i + 1);
        }
        
        return 1;
    }

    int setconstant(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        int index = (int)luaL_checkinteger(L, 2);
        luaL_checkany(L, 3);
        
        Proto* p = cl->l.p;
        if (index < 1 || index > p->sizek)
            luaL_error(L, "invalid constant index");
        
        TValue* k = &p->k[index - 1];
        
        switch (lua_type(L, 3))
        {
            case LUA_TNIL:
                setnilvalue(k);
                break;
            case LUA_TBOOLEAN:
                setbvalue(k, lua_toboolean(L, 3));
                break;
            case LUA_TNUMBER:
                setnvalue(k, lua_tonumber(L, 3));
                break;
            case LUA_TSTRING:
                setsvalue(L, k, tsvalue(luaA_toobject(L, 3)));
                break;
            default:
                luaL_error(L, "unsupported constant type");
                break;
        }
        
        return 0;
    }

    int getupvalue(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        int index = (int)luaL_checkinteger(L, 2);
        
        if (index < 1 || index > cl->nupvalues)
            luaL_error(L, "invalid upvalue index");
        
        luaC_threadbarrier(L);
        PushTValue(L, &cl->l.uprefs[index - 1]);
        return 1;
    }

    int getupvalues(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        lua_createtable(L, cl->nupvalues, 0);
        
        for (int i = 0; i < cl->nupvalues; i++)
        {
            luaC_threadbarrier(L);
            PushTValue(L, &cl->l.uprefs[i]);
            lua_rawseti(L, -2, i + 1);
        }
        
        return 1;
    }

    int setupvalue(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        int index = (int)luaL_checkinteger(L, 2);
        luaL_checkany(L, 3);
        
        if (index < 1 || index > cl->nupvalues)
            luaL_error(L, "invalid upvalue index");
        
        TValue* upval = &cl->l.uprefs[index - 1];
        const TValue* value = luaA_toobject(L, 3);
        
        setobj(L, upval, value);
        
        return 0;
    }

    int getproto(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        int index = (int)luaL_checkinteger(L, 2);
        bool activated = lua_toboolean(L, 3);
        
        Proto* p = cl->l.p;
        
        if (index < 1 || index > p->sizep)
        {
            lua_pushnil(L);
            return 1;
        }
        
        Proto* proto = p->p[index - 1];
        
        if (activated)
        {
            lua_newtable(L);
            
            for (int i = 0; i < cl->nupvalues; i++)
            {
                if (ttisfunction(&cl->l.uprefs[i]))
                {
                    Closure* upvalCl = clvalue(&cl->l.uprefs[i]);
                    if (!upvalCl->isC && upvalCl->l.p == proto)
                    {
                        lua_rawcheckstack(L, 1);
                        luaC_threadbarrier(L);
                        setclvalue(L, L->top, upvalCl);
                        incr_top(L);
                        int len = lua_objlen(L, -2);
                        lua_rawseti(L, -2, len + 1);
                    }
                }
            }
            
            return 1;
        }
        
        Closure* newCl = luaF_newLclosure(L, proto->nups, cl->env, proto);
        setclvalue(L, L->top, newCl);
        incr_top(L);
        
        for (int i = 0; i < proto->nups; i++)
            setnilvalue(&newCl->l.uprefs[i]);
        
        return 1;
    }

    int getprotos(lua_State* L)
    {
        Closure* cl = GetClosureFromArg(L, 1);
        
        if (cl->isC)
            luaL_error(L, "C closures are not supported");
        
        Proto* p = cl->l.p;
        
        lua_createtable(L, p->sizep, 0);
        
        for (int i = 0; i < p->sizep; i++)
        {
            Proto* proto = p->p[i];
            
            Closure* newCl = luaF_newLclosure(L, proto->nups, cl->env, proto);
            luaC_threadbarrier(L);
            setclvalue(L, L->top, newCl);
            incr_top(L);
            
            for (int j = 0; j < proto->nups; j++)
                setnilvalue(&newCl->l.uprefs[j]);
            
            lua_rawseti(L, -2, i + 1);
        }
        
        return 1;
    }

    int getstack(lua_State* L)
    {
        int level = (int)luaL_checkinteger(L, 1);
        
        if (level < 1)
            luaL_error(L, "stack level must be >= 1");
        
        if (unsigned(level) >= unsigned(L->ci - L->base_ci))
        {
            if (lua_isnone(L, 2))
            {
                lua_createtable(L, 0, 0);
                return 1;
            }
            lua_pushnil(L);
            return 1;
        }
        
        CallInfo* ci = L->ci - level;
        
        if (ci->flags & LUA_CALLINFO_NATIVE)
        {
            if (lua_isnone(L, 2))
            {
                lua_createtable(L, 0, 0);
                return 1;
            }
            lua_pushnil(L);
            return 1;
        }
        
        if (lua_isnone(L, 2))
        {
            int count = ci->top - ci->base;
            lua_createtable(L, count, 0);
            
            for (int i = 0; i < count; i++)
            {
                luaC_threadbarrier(L);
                PushTValue(L, ci->base + i);
                lua_rawseti(L, -2, i + 1);
            }
            
            return 1;
        }
        
        int index = (int)luaL_checkinteger(L, 2);
        int count = ci->top - ci->base;
        
        if (index < 1 || index > count)
        {
            lua_pushnil(L);
            return 1;
        }
        
        luaC_threadbarrier(L);
        PushTValue(L, ci->base + (index - 1));
        return 1;
    }

    int setstack(lua_State* L)
    {
        int level = (int)luaL_checkinteger(L, 1);
        int index = (int)luaL_checkinteger(L, 2);
        luaL_checkany(L, 3);
        
        if (level < 1)
            luaL_error(L, "stack level must be >= 1");
        
        if (unsigned(level) >= unsigned(L->ci - L->base_ci))
            luaL_error(L, "invalid stack level");
        
        CallInfo* ci = L->ci - level;
        
        if (ci->flags & LUA_CALLINFO_NATIVE)
            luaL_error(L, "C closures are not supported");
        
        int count = ci->top - ci->base;
        
        if (index < 1 || index > count)
            luaL_error(L, "invalid stack index");
        
        TValue* slot = ci->base + (index - 1);
        const TValue* value = luaA_toobject(L, 3);
        
        setobj(L, slot, value);
        
        return 0;
    }

    void RegisterLibrary(lua_State* L)
    {
        lua_newtable(L);
        
        Utils::AddTableFunction(L, "getconstant", Debug::getconstant);
        Utils::AddTableFunction(L, "getconstants", Debug::getconstants);
        Utils::AddTableFunction(L, "setconstant", Debug::setconstant);
        Utils::AddTableFunction(L, "getupvalue", Debug::getupvalue);
        Utils::AddTableFunction(L, "getupvalues", Debug::getupvalues);
        Utils::AddTableFunction(L, "setupvalue", Debug::setupvalue);
        Utils::AddTableFunction(L, "getproto", Debug::getproto);
        Utils::AddTableFunction(L, "getprotos", Debug::getprotos);
        Utils::AddTableFunction(L, "getstack", Debug::getstack);
        Utils::AddTableFunction(L, "setstack", Debug::setstack);
        
        lua_setglobal(L, "debug");
    }
}