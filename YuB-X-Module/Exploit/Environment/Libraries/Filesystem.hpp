#pragma once

#include <Windows.h>
#include <ShlObj.h>
#include <lstate.h>
#include <lualib.h>
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>

#include <Exploit/Utils.hpp>

namespace Filesystem
{
    inline const std::filesystem::path& get_workspace_path()
    {
        static const std::filesystem::path workspace = []() -> std::filesystem::path
        {
            char app_data_path[MAX_PATH];
            if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, app_data_path)))
            {
                std::filesystem::path path = std::filesystem::path(app_data_path) / "YuB-X-Public" / "workspace";
                if (!std::filesystem::exists(path))
                    std::filesystem::create_directories(path);
                return path;
            }
            return std::filesystem::temp_directory_path() / "YuB-X-Public" / "workspace";
        }();
        return workspace;
    }

    inline std::filesystem::path sanitize_path(const std::string& path)
    {
        const std::filesystem::path& workspace = get_workspace_path();
        std::filesystem::path full_path = workspace / path;

        std::error_code ec;
        std::filesystem::path canonical_path = std::filesystem::weakly_canonical(full_path, ec);

        if (ec)
            return {};

        std::string canonical_str = canonical_path.string();
        std::string workspace_str = workspace.string();

        if (canonical_str.length() < workspace_str.length() ||
            canonical_str.substr(0, workspace_str.length()) != workspace_str)
        {
            return {};
        }

        return canonical_path;
    }

    int writefile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        size_t data_len = 0;
        const char* data = luaL_checklstring(L, 2, &data_len);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }

        std::ofstream file(safe_path, std::ios::binary);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for writing");
            return 0;
        }

        file.write(data, data_len);
        file.close();

        return 0;
    }

    int readfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }

        if (!std::filesystem::exists(safe_path))
        {
            luaL_error(L, "File does not exist");
            return 0;
        }

        std::ifstream file(safe_path, std::ios::binary | std::ios::ate);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for reading");
            return 0;
        }

        std::streamsize size = file.tellg();
        file.seekg(0, std::ios::beg);

        std::string content(static_cast<size_t>(size), '\0');
        file.read(content.data(), size);
        file.close();

        lua_pushlstring(L, content.data(), content.size());

        return 1;
    }

    int appendfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);
        size_t data_len = 0;
        const char* data = luaL_checklstring(L, 2, &data_len);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }

        std::ofstream file(safe_path, std::ios::binary | std::ios::app);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for appending");
            return 0;
        }

        file.write(data, data_len);
        file.close();

        return 0;
    }

    int isfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            lua_pushboolean(L, false);
            return 1;
        }

        lua_pushboolean(L, std::filesystem::is_regular_file(safe_path));
        return 1;
    }

    int isfolder(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            lua_pushboolean(L, false);
            return 1;
        }

        lua_pushboolean(L, std::filesystem::is_directory(safe_path));
        return 1;
    }

    int delfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }

        if (std::filesystem::is_regular_file(safe_path))
            std::filesystem::remove(safe_path);

        return 0;
    }

    int delfolder(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe folder path");
            return 0;
        }

        if (std::filesystem::is_directory(safe_path))
            std::filesystem::remove_all(safe_path);

        return 0;
    }

    int makefolder(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe folder path");
            return 0;
        }

        std::filesystem::create_directories(safe_path);

        return 0;
    }

    int listfiles(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe folder path");
            return 0;
        }

        if (!std::filesystem::is_directory(safe_path))
        {
            lua_newtable(L);
            return 1;
        }

        lua_newtable(L);
        int index = 1;

        for (const auto& entry : std::filesystem::directory_iterator(safe_path))
        {
            lua_pushinteger(L, index);
            lua_pushstring(L, entry.path().filename().string().c_str());
            lua_settable(L, -3);
            index++;
        }

        return 1;
    }

    int loadfile(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }

        if (!std::filesystem::exists(safe_path))
        {
            luaL_error(L, "File does not exist");
            return 0;
        }

        std::ifstream file(safe_path, std::ios::binary | std::ios::ate);
        if (!file.is_open())
        {
            luaL_error(L, "Failed to open file for reading");
            return 0;
        }

        std::streamsize size = file.tellg();
        file.seekg(0, std::ios::beg);

        std::string content(static_cast<size_t>(size), '\0');
        file.read(content.data(), size);
        file.close();

        std::string chunkname = "@" + safe_path.filename().string();

        luaL_loadbuffer(L, content.data(), content.size(), chunkname.c_str());

        return 1;
    }

    int getcustomasset(lua_State* L)
    {
        const char* path = luaL_checkstring(L, 1);

        std::filesystem::path safe_path = sanitize_path(path);
        if (safe_path.empty())
        {
            luaL_error(L, "Invalid or unsafe file path");
            return 0;
        }

        if (!std::filesystem::exists(safe_path))
        {
            luaL_error(L, "File does not exist");
            return 0;
        }

        std::string content_url = "file:///" + safe_path.string();

        lua_pushstring(L, content_url.c_str());
        return 1;
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "writefile", Filesystem::writefile);
        Utils::AddFunction(L, "readfile", Filesystem::readfile);
        Utils::AddFunction(L, "appendfile", Filesystem::appendfile);
        Utils::AddFunction(L, "isfile", Filesystem::isfile);
        Utils::AddFunction(L, "isfolder", Filesystem::isfolder);
        Utils::AddFunction(L, "delfile", Filesystem::delfile);
        Utils::AddFunction(L, "delfolder", Filesystem::delfolder);
        Utils::AddFunction(L, "makefolder", Filesystem::makefolder);
        Utils::AddFunction(L, "listfiles", Filesystem::listfiles);
        Utils::AddFunction(L, "loadfile", Filesystem::loadfile);
        Utils::AddFunction(L, "getcustomasset", Filesystem::getcustomasset);
    }
}
