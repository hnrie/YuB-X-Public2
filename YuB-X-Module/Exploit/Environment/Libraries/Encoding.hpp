#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lualib.h>
#include <string>
#include <vector>
#include <cstdint>
#include <cstring>
#include <stdexcept>
#include <array>

#include <Dependencies/lz4/lz4.h>
#include <Exploit/Utils.hpp>

namespace Encoding
{
    // =========================================================================
    // Base64 implementation (RFC 4648, standard alphabet with '=' padding)
    // =========================================================================

    namespace Detail
    {
        // Encode alphabet
        static constexpr char kB64Chars[] =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        // Decode table: index = ASCII byte value, value = 6-bit group or 0xFF for invalid
        // Built at compile time as a constexpr array.
        static constexpr auto BuildDecodeTable() noexcept
        {
            std::array<uint8_t, 256> t{};
            for (auto& v : t) v = 0xFF;
            for (int i = 0; i < 64; ++i)
                t[static_cast<uint8_t>(kB64Chars[i])] = static_cast<uint8_t>(i);
            t[static_cast<uint8_t>('=')] = 0x00; // padding treated as 0
            return t;
        }

        static constexpr auto kB64Decode = BuildDecodeTable();

        inline std::string Base64Encode(const char* data, size_t len)
        {
            std::string out;
            out.reserve(((len + 2) / 3) * 4);

            size_t i = 0;
            for (; i + 2 < len; i += 3)
            {
                uint32_t v = (static_cast<uint8_t>(data[i])     << 16)
                           | (static_cast<uint8_t>(data[i + 1]) <<  8)
                           |  static_cast<uint8_t>(data[i + 2]);
                out += kB64Chars[(v >> 18) & 0x3F];
                out += kB64Chars[(v >> 12) & 0x3F];
                out += kB64Chars[(v >>  6) & 0x3F];
                out += kB64Chars[(v      ) & 0x3F];
            }

            if (i + 1 == len)       // one byte left → 2 output chars + ==
            {
                uint32_t v = static_cast<uint8_t>(data[i]) << 16;
                out += kB64Chars[(v >> 18) & 0x3F];
                out += kB64Chars[(v >> 12) & 0x3F];
                out += '=';
                out += '=';
            }
            else if (i + 2 == len)  // two bytes left → 3 output chars + =
            {
                uint32_t v = (static_cast<uint8_t>(data[i])     << 16)
                           | (static_cast<uint8_t>(data[i + 1]) <<  8);
                out += kB64Chars[(v >> 18) & 0x3F];
                out += kB64Chars[(v >> 12) & 0x3F];
                out += kB64Chars[(v >>  6) & 0x3F];
                out += '=';
            }
            return out;
        }

        inline std::string Base64Decode(const char* data, size_t len)
        {
            // Strip trailing whitespace / newlines that some producers emit
            while (len > 0 && (data[len - 1] == '\r' || data[len - 1] == '\n'
                                || data[len - 1] == ' ' || data[len - 1] == '\t'))
                --len;

            if (len % 4 != 0)
                throw std::runtime_error("base64decode: input length is not a multiple of 4");

            std::string out;
            out.reserve((len / 4) * 3);

            for (size_t i = 0; i < len; i += 4)
            {
                uint8_t a = kB64Decode[static_cast<uint8_t>(data[i    ])];
                uint8_t b = kB64Decode[static_cast<uint8_t>(data[i + 1])];
                uint8_t c = kB64Decode[static_cast<uint8_t>(data[i + 2])];
                uint8_t d = kB64Decode[static_cast<uint8_t>(data[i + 3])];

                if (a == 0xFF || b == 0xFF)
                    throw std::runtime_error("base64decode: invalid character in input");

                uint32_t v = (static_cast<uint32_t>(a) << 18)
                           | (static_cast<uint32_t>(b) << 12)
                           | (static_cast<uint32_t>(c) <<  6)
                           |  static_cast<uint32_t>(d);

                out += static_cast<char>((v >> 16) & 0xFF);

                if (data[i + 2] != '=')
                    out += static_cast<char>((v >> 8) & 0xFF);
                if (data[i + 3] != '=')
                    out += static_cast<char>( v       & 0xFF);
            }
            return out;
        }
    } // namespace Detail

    // =========================================================================
    // Lua-facing functions
    // =========================================================================

    int base64encode(lua_State* L)
    {
        size_t len = 0;
        const char* data = luaL_checklstring(L, 1, &len);
        std::string result = Detail::Base64Encode(data, len);
        lua_pushlstring(L, result.data(), result.size());
        return 1;
    }

    int base64decode(lua_State* L)
    {
        size_t len = 0;
        const char* data = luaL_checklstring(L, 1, &len);
        std::string result;
        try
        {
            result = Detail::Base64Decode(data, len);
        }
        catch (const std::exception& ex)
        {
            luaL_error(L, "%s", ex.what());
            return 0;
        }
        lua_pushlstring(L, result.data(), result.size());
        return 1;
    }

    int lz4compress(lua_State* L)
    {
        size_t srcLen = 0;
        const char* src = luaL_checklstring(L, 1, &srcLen);

        if (srcLen > static_cast<size_t>(LZ4_MAX_INPUT_SIZE))
        {
            luaL_error(L, "lz4compress: input too large");
            return 0;
        }

        // Allocate output: 4-byte LE prefix (original size) + LZ4 worst-case bound
        int bound      = LZ4_compressBound(static_cast<int>(srcLen));
        int prefixSize = 4; // uint32_t little-endian

        std::vector<char> buf(static_cast<size_t>(prefixSize + bound));

        // Write 4-byte little-endian original size
        uint32_t origSize = static_cast<uint32_t>(srcLen);
        buf[0] = static_cast<char>( origSize        & 0xFF);
        buf[1] = static_cast<char>((origSize >>  8) & 0xFF);
        buf[2] = static_cast<char>((origSize >> 16) & 0xFF);
        buf[3] = static_cast<char>((origSize >> 24) & 0xFF);

        int compressedBytes = LZ4_compress_default(src, buf.data() + prefixSize,
                                                    static_cast<int>(srcLen), bound);
        if (compressedBytes <= 0)
        {
            luaL_error(L, "lz4compress: compression failed");
            return 0;
        }

        lua_pushlstring(L, buf.data(), static_cast<size_t>(prefixSize + compressedBytes));
        return 1;
    }

    int lz4decompress(lua_State* L)
    {
        size_t srcLen = 0;
        const char* src = luaL_checklstring(L, 1, &srcLen);

        if (srcLen < 4)
        {
            luaL_error(L, "lz4decompress: input too short (missing size prefix)");
            return 0;
        }

        // Read 4-byte little-endian original size prefix
        uint32_t origSize =
              (static_cast<uint32_t>(static_cast<uint8_t>(src[0]))      )
            | (static_cast<uint32_t>(static_cast<uint8_t>(src[1])) <<  8)
            | (static_cast<uint32_t>(static_cast<uint8_t>(src[2])) << 16)
            | (static_cast<uint32_t>(static_cast<uint8_t>(src[3])) << 24);

        if (origSize == 0)
        {
            // Empty input special-case
            lua_pushlstring(L, "", 0);
            return 1;
        }

        if (origSize > 0x40000000u) // 1 GiB safety cap
        {
            luaL_error(L, "lz4decompress: declared decompressed size is unreasonably large");
            return 0;
        }

        std::vector<char> dst(static_cast<size_t>(origSize));

        int result = LZ4_decompress_safe(
            src + 4,
            dst.data(),
            static_cast<int>(srcLen - 4),
            static_cast<int>(origSize)
        );

        if (result < 0)
        {
            luaL_error(L, "lz4decompress: decompression failed (corrupt or invalid data)");
            return 0;
        }

        lua_pushlstring(L, dst.data(), static_cast<size_t>(result));
        return 1;
    }

    // =========================================================================
    // Registration
    // =========================================================================

    void RegisterLibrary(lua_State* L)
    {
        // --- Global scope ---
        Utils::AddFunction(L, "base64encode",  Encoding::base64encode);
        Utils::AddFunction(L, "base64decode",  Encoding::base64decode);
        Utils::AddFunction(L, "lz4compress",   Encoding::lz4compress);
        Utils::AddFunction(L, "lz4decompress", Encoding::lz4decompress);

        // --- crypt table alias (backwards compatibility) ---
        lua_newtable(L);
        Utils::AddTableFunction(L, "base64encode",  Encoding::base64encode);
        Utils::AddTableFunction(L, "base64decode",  Encoding::base64decode);
        Utils::AddTableFunction(L, "lz4compress",   Encoding::lz4compress);
        Utils::AddTableFunction(L, "lz4decompress", Encoding::lz4decompress);
        lua_setglobal(L, "crypt");
    }

} // namespace Encoding