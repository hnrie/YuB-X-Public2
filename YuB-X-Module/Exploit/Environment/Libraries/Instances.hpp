#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lualib.h>

#include <Exploit/Utils.hpp>
#include <Exploit/Globals.hpp>

namespace Instances
{
    int getinstances(lua_State* L)
    {
        lua_getglobal(L, "game");
        if (!lua_istable(L, -1) && !lua_isuserdata(L, -1))
        {
            lua_pop(L, 1);
            lua_newtable(L);
            return 1;
        }

        lua_getfield(L, -1, "GetDescendants");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 2);
            lua_newtable(L);
            return 1;
        }

        lua_pushvalue(L, -2);
        int status = lua_pcall(L, 1, 1, 0);

        if (status != LUA_OK || !lua_istable(L, -1))
        {
            if (status != LUA_OK)
                lua_pop(L, 1);
            lua_newtable(L);
        }

        lua_remove(L, -2);
        return 1;
    }

    int getnilinstances(lua_State* L)
    {
        lua_newtable(L);
        int index = 1;

        lua_getglobal(L, "game");
        if (!lua_istable(L, -1) && !lua_isuserdata(L, -1))
        {
            lua_pop(L, 1);
            return 1;
        }

        lua_getfield(L, -1, "GetDescendants");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 2);
            return 1;
        }

        lua_pushvalue(L, -2);
        int status = lua_pcall(L, 1, 1, 0);

        if (status != LUA_OK || !lua_istable(L, -1))
        {
            lua_pop(L, status != LUA_OK ? 2 : 3);
            return 1;
        }

        lua_pushnil(L);
        while (lua_next(L, -2))
        {
            if (lua_istable(L, -1) || lua_isuserdata(L, -1))
            {
                lua_getfield(L, -1, "Parent");
                bool isNil = lua_isnil(L, -1);
                lua_pop(L, 1);

                if (isNil)
                {
                    lua_pushinteger(L, index);
                    lua_pushvalue(L, -2);
                    lua_settable(L, -5);
                    index++;
                }
            }
            lua_pop(L, 1);
        }

        lua_pop(L, 2);
        return 1;
    }

    int compareinstances(lua_State* L)
    {
        if (lua_isnoneornil(L, 1) || lua_isnoneornil(L, 2))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        if ((!lua_istable(L, 1) && !lua_isuserdata(L, 1)) ||
            (!lua_istable(L, 2) && !lua_isuserdata(L, 2)))
        {
            lua_pushboolean(L, false);
            return 1;
        }

        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        bool same = lua_rawequal(L, -1, -2);
        lua_pop(L, 2);

        if (!same)
        {
            if (lua_getmetatable(L, 1) && lua_getmetatable(L, 2))
            {
                same = lua_rawequal(L, -1, -2);
            }
            lua_pop(L, 2);
        }

        lua_pushboolean(L, same);
        return 1;
    }

    int cloneref(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            lua_pushnil(L);
            return 1;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected Instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        lua_newtable(L);

        lua_pushvalue(L, 1);
        lua_setfield(L, -2, "__ref");

        lua_newtable(L);
        lua_pushcclosure(L, [](lua_State* LS) -> int
        {
            lua_getfield(LS, 1, "__ref");
            if (lua_isnoneornil(LS, -1))
            {
                lua_pop(LS, 1);
                return 0;
            }

            const char* key = lua_tostring(LS, 2);
            if (!key)
            {
                lua_pop(LS, 1);
                return 0;
            }

            lua_getfield(LS, -1, key);
            lua_replace(LS, -2);
            return 1;
        }, nullptr, 0);
        lua_setfield(L, -2, "__index");

        lua_pushcclosure(L, [](lua_State* LS) -> int
        {
            lua_getfield(LS, 1, "__ref");
            if (lua_isnoneornil(LS, -1))
            {
                lua_pop(LS, 1);
                return 0;
            }

            lua_pushvalue(LS, 2);
            lua_pushvalue(LS, 3);
            lua_settable(LS, -3);
            lua_pop(LS, 1);
            return 0;
        }, nullptr, 0);
        lua_setfield(L, -2, "__newindex");

        lua_pushcclosure(L, [](lua_State* LS) -> int
        {
            lua_getfield(LS, 1, "__ref");
            if (lua_isnoneornil(LS, -1))
            {
                lua_pop(LS, 1);
                lua_pushboolean(LS, false);
                return 1;
            }

            lua_pushvalue(LS, 2);
            bool eq = lua_rawequal(LS, -1, -2);
            lua_pop(LS, 2);
            lua_pushboolean(LS, !eq);
            return 1;
        }, nullptr, 0);
        lua_setfield(L, -2, "__eq");

        lua_setmetatable(L, -2);
        return 1;
    }

    int gethui(lua_State* L)
    {
        lua_getglobal(L, "game");
        if (!lua_istable(L, -1) && !lua_isuserdata(L, -1))
        {
            lua_pop(L, 1);
            lua_pushnil(L);
            return 1;
        }

        lua_getfield(L, -1, "GetService");
        if (!lua_isfunction(L, -1))
        {
            lua_pop(L, 2);
            lua_pushnil(L);
            return 1;
        }

        lua_pushvalue(L, -2);
        lua_pushstring(L, "CoreGui");
        int status = lua_pcall(L, 2, 1, 0);

        if (status != LUA_OK || lua_isnil(L, -1))
        {
            lua_pop(L, status != LUA_OK ? 2 : 1);
            lua_pushnil(L);
            return 1;
        }

        lua_remove(L, -2);
        return 1;
    }

    int fireclickdetector(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected ClickDetector, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected ClickDetector, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        lua_getfield(L, 1, "Parent");
        if (lua_isnoneornil(L, -1))
        {
            lua_pop(L, 1);
            luaL_error(L, "ClickDetector has no Parent");
            return 0;
        }
        lua_pop(L, 1);

        double distance = luaL_optnumber(L, 2, 9e9);
        const char* event = luaL_optstring(L, 3, "MouseClick");

        lua_getglobal(L, "game");
        lua_getfield(L, -1, "GetService");
        lua_pushvalue(L, -2);
        lua_pushstring(L, "Players");
        lua_pcall(L, 2, 1, 0);
        lua_remove(L, -2);

        lua_getfield(L, -1, "LocalPlayer");
        lua_remove(L, -2);

        if (lua_isnil(L, -1))
        {
            lua_pop(L, 1);
            luaL_error(L, "No LocalPlayer found");
            return 0;
        }

        lua_getfield(L, 1, event);
        if (lua_isfunction(L, -1))
        {
            lua_pushvalue(L, 1);
            lua_pushvalue(L, -3);
            lua_pushnumber(L, distance);
            lua_pcall(L, 3, 0, 0);
        }
        else
        {
            lua_pop(L, 1);

            lua_getfield(L, 1, "Fire");
            if (lua_isfunction(L, -1))
            {
                lua_pushvalue(L, 1);
                lua_pushvalue(L, -3);
                lua_pushnumber(L, distance);
                lua_pcall(L, 3, 0, 0);
            }
            else
            {
                lua_pop(L, 1);
            }
        }

        lua_pop(L, 1);
        return 0;
    }

    int firetouchinterest(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected BasePart for argument 1, got nil");
            return 0;
        }

        if (lua_isnoneornil(L, 2))
        {
            luaL_error(L, "expected BasePart for argument 2, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected BasePart for argument 1, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        if (!lua_istable(L, 2) && !lua_isuserdata(L, 2))
        {
            luaL_error(L, "expected BasePart for argument 2, got %s", lua_typename(L, lua_type(L, 2)));
            return 0;
        }

        int toggle = 0;
        if (lua_isboolean(L, 3))
        {
            toggle = lua_toboolean(L, 3) ? 0 : 1;
        }
        else if (lua_isnumber(L, 3))
        {
            toggle = static_cast<int>(lua_tonumber(L, 3));
        }

        const char* eventName = (toggle == 0) ? "Touch" : "TouchEnded";

        lua_getfield(L, 2, eventName);
        if (lua_isfunction(L, -1))
        {
            lua_pushvalue(L, 2);
            lua_pushvalue(L, 1);
            lua_pcall(L, 2, 0, 0);
        }
        else
        {
            lua_pop(L, 1);
        }

        return 0;
    }

    int fireproximityprompt(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected ProximityPrompt, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected ProximityPrompt, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        lua_getfield(L, 1, "Fire");
        if (lua_isfunction(L, -1))
        {
            lua_pushvalue(L, 1);
            lua_pcall(L, 1, 0, 0);
        }
        else
        {
            lua_pop(L, 1);

            lua_getfield(L, 1, "InputHoldBegin");
            if (lua_isfunction(L, -1))
            {
                lua_pushvalue(L, 1);
                lua_pcall(L, 1, 0, 0);
            }
            lua_pop(L, 1);

            lua_getfield(L, 1, "InputHoldEnd");
            if (lua_isfunction(L, -1))
            {
                lua_pushvalue(L, 1);
                lua_pcall(L, 1, 0, 0);
            }
            lua_pop(L, 1);

            lua_getfield(L, 1, "Triggered");
            if (lua_istable(L, -1) || lua_isuserdata(L, -1))
            {
                lua_getfield(L, -1, "Fire");
                if (lua_isfunction(L, -1))
                {
                    lua_pushvalue(L, -2);
                    lua_pcall(L, 1, 0, 0);
                }
                else
                {
                    lua_pop(L, 1);
                }
            }
            lua_pop(L, 1);
        }

        return 0;
    }

    int getcallbackvalue(lua_State* L)
    {
        if (lua_isnoneornil(L, 1))
        {
            luaL_error(L, "expected Instance, got nil");
            return 0;
        }

        if (!lua_istable(L, 1) && !lua_isuserdata(L, 1))
        {
            luaL_error(L, "expected Instance, got %s", lua_typename(L, lua_type(L, 1)));
            return 0;
        }

        const char* property = luaL_checkstring(L, 2);
        if (!property)
        {
            lua_pushnil(L);
            return 1;
        }

        lua_getfield(L, 1, property);
        return 1;
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "getinstances", Instances::getinstances);
        Utils::AddFunction(L, "getnilinstances", Instances::getnilinstances);
        Utils::AddFunction(L, "compareinstances", Instances::compareinstances);
        Utils::AddFunction(L, "cloneref", Instances::cloneref);
        Utils::AddFunction(L, "gethui", Instances::gethui);
        Utils::AddFunction(L, "fireclickdetector", Instances::fireclickdetector);
        Utils::AddFunction(L, "firetouchinterest", Instances::firetouchinterest);
        Utils::AddFunction(L, "fireproximityprompt", Instances::fireproximityprompt);
        Utils::AddFunction(L, "getcallbackvalue", Instances::getcallbackvalue);
    }
}
