#include <Exploit/Globals.hpp>
#include <Exploit/Execution/Execution.hpp>
#include <Exploit/Environment/Environment.hpp>
#include <Exploit/TaskScheduler/TaskScheduler.hpp>
#include <Exploit/Environment/Yielding/Yielding.hpp>

void task_scheduler::set_proto_capabilities(Proto* proto, uintptr_t* capabilities)
{
    proto->userdata = capabilities;
    for (int i = 0; i < proto->sizep; ++i)
        set_proto_capabilities(proto->p[i], capabilities);
}

void task_scheduler::set_thread_capabilities(lua_State* L, int level, uintptr_t capabilities)
{
    L->userdata->identity = level;
    L->userdata->capabilities = capabilities;
}

uintptr_t task_scheduler::get_data_model()
{
    uintptr_t fake_data_model = *reinterpret_cast<uintptr_t*>(offsets::data_model::fake_data_model_pointer);
    uintptr_t data_model = *reinterpret_cast<uintptr_t*>(fake_data_model + offsets::data_model::fake_data_model_to_data_model);

    return data_model;
}

uintptr_t task_scheduler::get_script_context(uintptr_t data_model)
{
    uintptr_t children = *reinterpret_cast<uintptr_t*>(data_model + offsets::data_model::children);
    uintptr_t script_context = *reinterpret_cast<uintptr_t*>(*reinterpret_cast<uintptr_t*>(children) + offsets::data_model::script_context);

    return script_context;
}

lua_State* task_scheduler::get_lua_state_for_instance(uintptr_t instance)
{
    *reinterpret_cast<BOOLEAN*>(instance + offsets::extra_space::require_bypass) = TRUE;

    uint64_t null = 0;
    return roblox::get_lua_state_for_instance(instance, &null, &null);
}

int scripts_handler(lua_State* L)
{
    {
        std::lock_guard<std::mutex> lock(shared_variables::execution_mutex);
        if (!shared_variables::execution_requests.empty())
        {
            std::string script = std::move(shared_variables::execution_requests.front());
            shared_variables::execution_requests.pop_front();
            execution::execute_script(shared_variables::exploit_thread, script);
        }
    }
    yielding::run_yield();

    return 0;
}

void setup_execution(lua_State* L)
{
    lua_getglobal(L, "game");
    lua_getfield(L, -1, "GetService");
    lua_pushvalue(L, -2);

    lua_pushstring(L, "RunService");
    lua_pcall(L, 2, 1, 0);

    lua_getfield(L, -1, "RenderStepped");
    lua_getfield(L, -1, "Connect");
    lua_pushvalue(L, -2);

    lua_pushcclosure(L, scripts_handler, nullptr, 0);
    lua_pcall(L, 2, 0, 0);
    lua_pop(L, 2);
}

bool task_scheduler::setup_exploit()
{
    uintptr_t script_context = task_scheduler::get_script_context(shared_variables::last_data_model);
    lua_State* roblox_state = task_scheduler::get_lua_state_for_instance(script_context);

    shared_variables::exploit_thread = lua_newthread(roblox_state);
    task_scheduler::set_thread_capabilities(shared_variables::exploit_thread, 8, max_capabilities);
    environment::setup_environment(shared_variables::exploit_thread);
    setup_execution(shared_variables::exploit_thread);

    return true;
}

void task_scheduler::request_execution(const std::string& script)
{
    std::lock_guard<std::mutex> lock(shared_variables::execution_mutex);
    shared_variables::execution_requests.push_back(script);
}
