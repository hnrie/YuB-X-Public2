#include <Exploit/Globals.hpp>
#include <Exploit/Environment/Yielding/Yielding.hpp>

void yielding::run_yield()
{
    std::function<void()> yielding_request;
    {
        std::lock_guard<std::mutex> lock(shared_variables::yield_mutex);
        if (shared_variables::yield_queue.empty())
            return;
        yielding_request = std::move(shared_variables::yield_queue.front());
        shared_variables::yield_queue.pop();
    }
    yielding_request();
}

int yielding::yield_execution(lua_State* L, const std::function<yielded()>& yielding_closure)
{
    lua_pushthread(L);
    int yielded_thread_ref = lua_ref(L, -1);
    lua_pop(L, 1);

    std::thread([=]
    {
        yielded resume_function = yielding_closure();

        {
            std::lock_guard<std::mutex> lock(shared_variables::yield_mutex);
            shared_variables::yield_queue.emplace([=]() -> void
            {
                WeakThreadRef weak_thread_ref_object = { L };
                lua_pushthread(L);
                weak_thread_ref_object.thread_ref = yielded_thread_ref;
                lua_pop(L, 1);
                WeakThreadRef* weak_thread_ref = &weak_thread_ref_object;

                DebuggerResult debugger_result = { 0 };
                auto script_context = reinterpret_cast<uintptr_t>(L->userdata->sharedExtraSpace->scriptContext);
                roblox::script_context_resume(script_context + offsets::extra_space::script_context_to_resume, &debugger_result, &weak_thread_ref, resume_function(L), NULL, NULL);

                lua_unref(L, yielded_thread_ref);
            });
        }
    }).detach();

    return lua_yield(L, 0);
}
